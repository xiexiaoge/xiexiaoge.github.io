{"meta":{"title":"小哥","subtitle":"小哥","description":"个人笔记","author":"小哥","url":"xiexiaoge.github.io"},"pages":[{"title":"about","date":"2018-01-20T04:13:10.000Z","updated":"2018-01-20T08:13:22.493Z","comments":true,"path":"about/index.html","permalink":"xiexiaoge.github.io/about/index.html","excerpt":"","text":"刚写博客,可能内容不是很nice,但是希望自己能坚持,技术就像粥,越熬越有味!"}],"posts":[{"title":"JS基础-原型和原型链","slug":"JS基础-原型和原型链","date":"2018-01-21T15:14:24.000Z","updated":"2018-01-21T15:34:33.382Z","comments":true,"path":"2018/01/21/JS基础-原型和原型链/","link":"","permalink":"xiexiaoge.github.io/2018/01/21/JS基础-原型和原型链/","excerpt":"","text":"原型和原型链 原型 所有的函数都天生自带一个属性: prototype(原型),它是一个对象数据类型的值 , 在当前prototype对象中,存储了类需要给实例使用的公有的属性和方法 prototype这个对象,浏览器会默认为其开辟一个堆内存,在这个堆内存中天生自带一个属性constructor(构造函数),这个属性存储的值就是当前函数本身 每一个类的实例(每一个对象)都天生自带一个属性: __proto__ , 属性值是当前对象所属类的原型(prototype)1234567 function Fn(name,age)&#123; this.name=name; this.age=age; this.say=function()&#123; console.log(\"my name is\"+this.name+\"! i am \" + this.age +\"years old !\"); &#125;&#125; 关于原型链中提供的私有(公有)中的this指向问题 看点前面是谁,this就是谁 把需要执行方法中的this进行替换 替换完成后,如果想要知道结果,只需要按照原型链的查找机制去查找即可 基于自定义类的原型扩展方法 1234function Fn(name,age)&#123; this.name=name; this.age=age;&#125;; 设置别名(小名) 1234var pro=Fn.prototype;//=&gt;指向同一个堆内存 pro.get=function () &#123;&#125;; pro.set=function () &#123;&#125;;constructor问题和之前原型上的方法 内置类不允许重新构造原型 重新构造原型 123456Fn.prototype=&#123; //=&gt; 让原型指向自己开辟的堆内存有一个问题:自己开辟的堆内存中没有constructor这个属性,所以实例在调取constructor的时候找到的是Object,这样不好,此时我们应该重新设置一下constructor,保证机制的完整性 constructor:Fn, get:function () &#123;&#125;, set:function () &#123;&#125;&#125;; 12345678910111213在JQ中就是采用了重新构造原型的方式~function () &#123; var jQuery=function (seletor,context) &#123; return new jQuery.fn.init(seletor,context) &#125;; jQuery.fn=jQuery.prototype=&#123; constructor:jQuery, init:function (seletor,context) &#123; &#125; &#125;; window.$=window.jQuery=jQuery;&#125;(); 基于内置类的原型扩展方法 我们新增加的方法最好设置一个前缀,防止我们新增加的方法内置的方法冲突,把内置方法替换掉 实现链式写法,这样执行完成这个方法后,我们还可以继续调取其它的方法 123456789101112131415161718Array.prototype.myDistinct=function () &#123; var obj=&#123;&#125;; for(var i=0;i&lt;this.length;i++)&#123; var item=this[i]; if(typeof obj[item] !==&quot;undefined&quot;)&#123; this[i]=this[this.length-1]; this.length--; i--; continue; &#125; obj[item]=item; &#125; obj=null; return this;//实现链式写法,返回去重后的数组,这样执行完成这个方法后,我们还可以继续调取数组中的方法&#125;;let ary=[1,6,4,5,2,5,5];ary.myDistinct();console.log(ary);","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-构造函数模式","slug":"JS基础-构造函数模式","date":"2018-01-21T15:03:22.000Z","updated":"2018-01-21T15:13:25.282Z","comments":true,"path":"2018/01/21/JS基础-构造函数模式/","link":"","permalink":"xiexiaoge.github.io/2018/01/21/JS基础-构造函数模式/","excerpt":"","text":"构造函数设计模式(constructor) 使用构造函数方式,主要是为了创建类和实例的,也就是基于面向对象编程思想来实现一些需求的处理 在JS中, 当我们使用new xxx()执行函数的时候,此时的函数就不是普通的函数了,而是变为了一个类,返回的结果叫做当前类的实例,把这种new xxx执行的方式称之为构造函数设计模式1234function Fn()&#123; ...&#125;var f = new Fn();//=&gt; Fn是一个类,f是当前这个类的一个实例 \"构造函数设计模式\"(我们一般都会把类名第一个字母大写) 普通函数执行 VS 构造函数执行 普通函数执行 开辟一个新的私有作用域 形参赋值 变量提升 代码自上而下执行(return 后面的值就是当前函数返回的结果) 栈内存释放或者不释放1234567function fn(num)&#123; this.num=num;//this-&gt;window 相当于给全局对象增加一个num的属性,属性值是 形参num var total=null; total+=num; return total&#125;var f=fn(10); //=&gt; 10 构造函数执行 首先和普通函数执行一样,也需要开辟一个新的私有作用域 私有作用域中完成类似于普通函数的操作: 形参赋值以及变量提升 在代码自上而下执行之前,构造函数有属于自己比较特殊的操作 : 浏览器会在当前的作用域中默认创建一个对象数据类型的值,并且会让当前函数中的this指向创建的这个对象 像普通函数一样,代码自上而下执行:this.xxx=xxx这里操作都是在给创建的这个对象增加属性名和属性值 代码执行完之后,即时然后中没有写return,在构造函数模式中: 浏览器会默认把创建的对象返回到函数的外面12345 function Fn(num)&#123; //=&gt;在构造函数模式中,方法中出现的this是当前类的一个实例(this.xxx=xxx都是给当前实例添加一些私有的属性) this.num=num;&#125;var f=new Fn(10); 构造函数执行,即具备普通函数执行的一面,也同时具备自己独有的一些操作 在构造函数执行期间,浏览器默认创建的对象(也就是函数体中的this)就是当前这个类的一个实例,浏览器会把默认创建的实例返回,所以 new Fn(), Fn是一个类,返回的结果是Fn这个类的一个实例 深入理解构造函数执行的步骤 当构造函数或者类,执行的时候不需要传递任何的实参值,此时我们是否加小括号就不重要了(不需要传递实参的情况下,小括号可以省略) 构造函数执行,同时具备了普通函数执行的一面,也有自己特殊的一面,但是和实例相关的只有自己特殊的一面才相关(也就是this.xxx=xxx才相当于给当前实例增加的私有属性),函数体中出现的私有变量,和实例都没有直接的关系 通过类创建出来的每一个实例都是单独的个体(单独的堆内存空间) , 实例和实例之间是不相同并且独立互不影响的(市面上部分开发把这种模式叫做单例模式,这种说法是错的,JS中这种模式叫做构造函数设计模式) 在构造函数体中,通过this.xxx=xxx给实例设置的属性都是当前实例的私有属性 12345678910111213function Fn()&#123; var num=100; this.name=\"小哥\";&#125;var f1=new Fn();var f2=new Fn//=&gt;私有变量和实例没关系console.log(f1.num)// nudefinedconsole.log(f1.name)// \"小哥\"//=&gt;不同实例是不同的空间地址 console.log(f1===f2) //false 当构造函数体中我们手动的设置了return(默认返回的是实例:对象数据类型值),return的是一个基本类型值,对最后返回的实例没有任何影响,但是如果返回的是引用数据类型的值的话,会把默认返回的实例替换掉123456789101112function Fn()&#123; this.name=\"小哥\"; return 10;&#125;var f=new Fn();//=&gt;f依然是当前类的一个实例function Fn()&#123; this.name=\"小哥\"; return &#123;name:\"小明\"&#125;;&#125;var f=new Fn();//=&gt;f不再是Fn是实例,而是变为手动返回的对象了 instanceof 用来检测当前实例是否隶属某个类 123function Fn()&#123;&#125;var f=new Fn;console.log(f instanceof Fn) //=&gt;true instanceof解决了typeof无法识别是数组还是正则的问题 12[] instanceof Array // =&gt; true/^$/ instanceof Array //=&gt; false hasOwnProperty VS in in : 用来检测当前这个是属性是否隶属于对象(不管是对象私有的还是公有的属性,只要有返回的就是true) hasOwnProperty : 用来检测当前这个属性是否是对象的私有属性(不仅是对象的属性,而且需要是私有的才可以) 1234567var obj = &#123;name:\"小哥\",age:18&#125;;\"name\" in obj //=&gt;true\"sex\" in obj //=&gt;false\"hasOwnProperty\" in obj //=&gt;truehas是Oobject这个内之类中提供的属性方法,只要当前对象是Objeact的一个实例,就可以使用这个方法obj.hasOwnProerty(\"name\") //=&gt;true 检测一个属性是否是当前对象的公有属性 是对象的一个属性 不是对象的私有属性1234567function hasPubProPerty (obj,property) &#123; obj = obj.toString() == \"[object Object]\" ? obj : &#123;&#125;; property=typeof property==\"string\"?property:\"\"; return (property in obj) &amp;&amp;(obj.hasOwnProperty(property)===false); // return property in obj?obj.hasOwnProperty(property)?false:true:false&#125;console.log(hasPubProPerty (&#123;name: \"小哥\"&#125;, \"hasOwnProperty\"));","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-面向对象","slug":"JS基础-面向对象","date":"2018-01-20T16:40:59.000Z","updated":"2018-01-20T16:52:49.916Z","comments":true,"path":"2018/01/21/JS基础-面向对象/","link":"","permalink":"xiexiaoge.github.io/2018/01/21/JS基础-面向对象/","excerpt":"","text":"面向对象(oop) 面向对象是编程思想 HTML和CSS是标记语言不是编程语言,没有所谓的面向对象编程 LESS和SASS属于CSS预编译语言,把CSS编程编程语言(面向对对象) 对象,类,实例 对象 : 编程语言中的对象是一个泛指,万物皆对象(所要研究学习以及使用的都是对象) 类 : 对象的具体细分(按照对象或者特性细分为一些类别) 实例 : 某一类中具体的事物 实际生活中 自然界中万物皆对象,我们为了认知自然界,我们会把自然界中的事物按照特征进行分类,例如: 动物类 人类 正常人类 程序猿类 爬行动物类 植物类 微生物类 …每个程序员就是程序猿类别中的一个实例 JS本身就是基于面向对象创造出来的语言(所以它是面向对象编程),我们想要学习JS,首先也是给其进行分类,拿出某一勒种的实例,进行学习和研究 JS中常用的内置类 关于数据类型的 Number : 每一个数字或者NaN是它的一个实例 String : 字符串类 Boolean : 布尔类 Undefined / Null : 浏览器屏蔽了我们操作Null或者Undefined这个类 Object : 对象类,每一个对象数据类型都是它的实例 Array : 数组类 RegExp : 正则类 Date : 日期类 … Function : 函数类,每一个函数都是它的一个实例 关于元素对象和元素集合的 HTMLCollection : 元素集合类 NodeList : 节点集合类 HTMLElement HTML类 Element 标签类 Node 节点类 EventTarget 事件类 12345678 //=&gt;元素集合类 getElementsByTagName getElementsByClassName querySelectorAll//=&gt;节点集合类 getELementsByName childNodes 学习面对对象对于小白的意义 研究数组: 创建一个数组类的实例,研究其基础语法和结构 如果想要研究数据具备的功能方法,我们只需要看Array/Object这些类上都赋予了它什么样的方法 document.getElementById它的上下文只能是document,其它不不可以? 因为getElementById这个方法只有Document这个类才有,其它类没有,所以只有document这个作为Document的实例才能使用这个方法 基于面向对象创建数据值 引用数据类型 1234567891011121314//=&gt;字面量创建方式 var ary =[1,2,3];// 基于面向对象(构造函数)方式创建一个数组 var ary = new Array(); 两种创建方式在核心意义上没有差别,都是创建Array这个类的一个实例,但是语法上是有去别的 1. 字面量创建方式传递进来什么,都是给数组每一项加入的内容 2. 构造函数创建方式 new Array(10); 创建一个长度为10的数组,每一项都是空 new Array(\"10\");如果只传递一个实参,并且实参不是数组,相当于把当前值作为一个数组的第一项存起来 new Array(10,20,30):如果传递多个实参,不设置长度,而是把传递的内容当作数组中的每一项存储起来var obj=&#123;name:\"小哥\"&#125;;var obj=new Object();//=&gt;一般只用于创建空对象,如果需要增加键值对,创建完成后自己依次添加即可 基本数据类型 12345var num =12 ;//=&gt;字面量创建出来的是一个基本数据类型值(但是也是Number的一个实例,可以调取Number赋予它的方法)typeOf num //=&gt; &quot;number&quot;var num = new Number(12);//=&gt;构造函数方式创建出来的也是Number的一个实例(也可以使用Number赋予它的方法),但是获取的结果是对象数据类型的typeOf num //=&gt; &quot;object&quot;","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-单例模式","slug":"JS基础-单例模式","date":"2018-01-20T16:23:52.000Z","updated":"2018-01-20T16:36:16.027Z","comments":true,"path":"2018/01/21/JS基础-单例模式/","link":"","permalink":"xiexiaoge.github.io/2018/01/21/JS基础-单例模式/","excerpt":"","text":"单例模式 把对象数据类型实现把描述同一件事物或者特征归纳汇总在一起,以此来避免全局变量问题的方式和思想叫做:单例设计模式 123456789101112131415161718//=&gt;单例模式//1.singleto不仅仅是对象名了,在单例模式中.singleton称之为\"命名空间(nameSpace)\"var singleton=&#123; xxx:xxx, ...&#125;;var singletonFn=&#123; nameSace1:&#123; xxx:xxx, .... &#125;nameSace2:&#123; xxx:xxx, .... &#125;.....&#125; 在项目中,为了实现模块化开发或者团队协作开发,我们经常应用单利模式(一般页面逻辑部分的代码都是依托单例模式设计规划的);模块化开发,在团队协作开发的时候,我们经常会把一个复杂页面,按照具体的功能划分成为几大块,然后分别去开发,这种模式划分的思想就是模块化开发思想 使用单例模式实现模块化开发 在自己命名空间下调用其他命名空间的方法,指定好对应的命名空间名即可1234567891011example 1var singleton1=&#123; show:function()&#123; &#125;&#125;var stinleton2=&#123; hide:function()&#123; singleton1.show(); &#125;&#125; 调用本模块中的一些方法,可以直接使用this处理即可,此方法中的this一般都是当前模块的命名空间123456789example 2var singleton1=&#123; show:function()&#123; &#125;, hide:function()&#123; this.show(); &#125;&#125; 高级单例模式 基础JS高级编程技巧惰性思想来实现的单例模式,并且可以把一些常用的设计模式(例如:命令模式,发布订阅设计模式,promise设计模式等)融合进来,最后清晰的规划我们的业务逻辑代码,方便后期二次开发和维护,这种设计思想综合体就是高级单例模式,也是项目中最常应用的 单例模式+发布订阅模式 12345678910111213141516171819var searchModel=(function()&#123; var $searchPlan=$.Callbacks();//jQuery中的发布订阅模式 function submit()&#123; .... &#125; $searchPlan.add(sumbit); function fn()&#123; .... &#125; $searchPlan.add(fn); return&#123; init:function()&#123; $searchPlan.fire() &#125; &#125;&#125;)()searchModel.init();","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-作用域和闭包","slug":"JS基础-作用域和闭包","date":"2018-01-20T07:18:37.000Z","updated":"2018-01-20T17:30:38.281Z","comments":true,"path":"2018/01/20/JS基础-作用域和闭包/","link":"","permalink":"xiexiaoge.github.io/2018/01/20/JS基础-作用域和闭包/","excerpt":"","text":"JS中的堆内存和栈内存 栈内存俗称叫做作用域(全局作用域/私有作用域) 为JS代码提供执行的环境(执行JS代码的地方) 基本数据类型值是直接存放在栈内存中的 堆内存存储数据类型值(相当于一个存储的仓库) 对象存储的是键值对 函数存储的是代码字符串 在项目中,内存越少性能越好,需要把一些没用的内存处理掉 栈内存和堆内存的销毁 堆内存 函数执行形成一个私有作用域,如果私有作用域中的部分内容被以外的变量占用了,当前作用域不销毁 函数执行返回一个引用数据类型堆内存地址(并且堆内存隶属于这个作用域),在外面有一个变量接受了这个返回值,此时当前作用就不能销毁(想要销毁,只需要让外面的变量赋值给null,也就是不占用当前作用域中的内容了) 栈内存 全局作用域在加载页面的时候执行,在关掉页面的时候销毁 私有作用域一般情况下,函数执行形成栈内存,函数执行完,浏览器会把执行的栈内存自动释放;特殊情况:私有作用域的部分内存被其他作用域知道了,那么该栈内存就属于被占用,不会被销毁,常见的两种情况:1. 函数执行返回一个引用类型的值,且在别的作用域被接收了,该栈内存不会被销毁 2. 私有作用域中,给DOM元素的事件绑定方法,该栈内存不会被销毁 作用域 全局作用域: window 私有作用域: 函数执行 块级作用域:使用let创建变量存在块级作用域 作用域链 当前作用域代码执行的时候遇到一个变量,首先看它是否属于私有变量,如果是当前作用域私有变量,那么以后私有作用域中遇到这个变量都是操作私有的(闭包); 如果当前这个变量不是私有的,我们需要向它的上级作用域进行查找,上级如果也没有,则继续向上查找,一直找到window全局作用域为止,我们把着种查找机制叫做作用域链;全局下右,操作的就是全局变量,全局下没有(设置:给全局对象window增加了属性&amp;&amp;获取:报错) 查找私有变量 JS中的私有变量有且有两种 在私有作用域变量提升阶段,声明过的变量(或函数) 形参也是私有变量1234567example 1function fn(num1,num2)&#123; // total,num1,num2 私有变量 var total=num1+num2; return total&#125;var result=fn(100,200) 函数执行 函数执行形成一个新的私有作用域 形参赋值 变量提升 代码自上而下执行 当前栈内存(私有作用域)销毁或者不销毁 123456789101112131415example 2//全局作用域下的变量提升 var x,y,z,fn=xxxfff1111var x=10,y=20,z=30;function fn(x,y)&#123; //私有作用域 // 形参赋值: x=10,y=20 (x,y)私有变量 // 变量提升 var x(忽略的,因为已经存在x这个名字了) console.log(x,y,z);//z全局变量 10 20 30 var x=100;//私有的x=100 y=200;//私有的y=200 z=300;//全局的z变成300 console.log(x,y,z);//100,200,300&#125;fn(x,y,z);//fn 执行传递的是实参(实参都是值)console.log(x, y, z); //10 20 300 123456789101112131415example 3//全局变量 fn=&gt;xxxfff111function fn(b)&#123; //私有作用域 // 形参赋值 b=1 //变量提升 b=&gt;函数 console.log(b);// 函数b function b() &#123; //私有作用域 //形参赋值和变量提升都没有 console.log(b);//函数b &#125; b();&#125;fn(1); 如何查找上一级作用域? 函数执行形成一个私有作用域(A),A的上级作用域是谁,和他在哪执行的没关系,主要看他是在哪定义的,在哪个作用域下定义的,当前A的上级作用域就是谁; 12345678910examplt 4var n=10;function sum() &#123; console.log(n);&#125;//sum(); =&gt;10~function () &#123; var n=100; sum();//=&gt;10 sum的宿主环境是当前自执行函数形成的私有作用域&#125;(); 闭包 函数执行,形成一个私有作用域,保护里面的私有变量不受到外界的干扰,这种保护机制叫做 闭包 闭包的作用(保护) 形成私有作用域,保护里面的私有变量不受外界的干扰 JQuery:常用的JS类库,提供很多项目中常用的方法(兼容所有浏览器) Zepto: 小型JQ,专门为移动端开发准备的 123456789101112131415161718//=&gt;JQ代码片段(function(window)&#123; var jQuery=function()&#123; ...&#125;;window.jQuery=window.$=jQuery;&#125;)(window)jQuery()$()//=&gt;Zepto代码片段var Zepto=(function()&#123; var Zepto=function()&#123; ... &#125; return Zepto&#125;)()Zepto(); 在项目中,利用这种保护机制,实现团队协作开发(避免了多人同一个命名,导致代码冲突的问题) 闭包的作用(保存) 函数执行形成一个私有作用域,函数执行完成,形成的这个栈内存一般情况下都会自动释放 特殊情况:函数执行完成,当前私有作用域(栈内存)中的某一部分被栈内存以外的其它东西(变量/元素的事件)占用了,当前的栈内存就不能释放掉,也就形成了不销毁的私有作用域(里面的私有变量也不会销毁) i++和++i的区别 i++: 先拿原有的i值和其他值进行运算,运算完成后在自身累加1++i: 先自身累加1,然后拿累加完成的结果和其他值进行运算1234567var i=5;console.log(5+i++);//10console.log(i)//=&gt;6var i=5;console.log(5+++i);//11console.log(i)//=&gt;6","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-this问题","slug":"JS基础-this问题","date":"2018-01-20T07:14:38.000Z","updated":"2018-01-20T08:07:59.658Z","comments":true,"path":"2018/01/20/JS基础-this问题/","link":"","permalink":"xiexiaoge.github.io/2018/01/20/JS基础-this问题/","excerpt":"","text":"在JS非严格模式下(默认模式就是非严格模式) 1 自执行函数中的this一般都是window1234567var obj=&#123; fn:(function)&#123; //this-&gt;window return function()&#123; &#125; &#125;()&#125; 2 给元素的某个事件绑定方法,当事件触发执行对应方法的时候,方法中的this一般都是当前操作的元素本身123oBox.onclick=function()&#123; //this-&gt;oBox&#125; 3 还有一个方式可以快速区别this : 当方法执行的时候,看看方法名前面是否有点,有点,点前面是谁this就是谁,没有点一般都是window123456789var obj=&#123; name: \"obj\", fn:function()&#123; console.log(this) &#125;&#125;obj.fn();//this-&gt;objvar f=obj.fn;f();//this-&gt;window 4.当一个函数作为参数的时候，this也是window 切记: 1. ES6的箭头函数中没有this指向 2. this是谁和他在哪定义的以及在哪执行的没有任何关系 在JS严格模式下(让JS更加严谨) 开始严格模式 : 在当前作用域的第一行加上&quot;user strict&quot;,开启严格模式,那么当前作用域下在执行的JS代码都是按照严格模式处理的;12\"user strict\";//=&gt;当前JS代码都开启了严格模式(包含了函数中的代码) 1234~function()&#123;\"use strict\";//-&gt;只是把当前私有作用域开启了严格模式(对外面全局没有影响)&#125;(); 在JS严格模式下,如果执行主题不明确,this指向的是undefined(非严格模式下指向的是window)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-变量提升","slug":"JS基础-变量提升","date":"2018-01-19T17:24:53.000Z","updated":"2018-01-20T17:10:43.145Z","comments":true,"path":"2018/01/20/JS基础-变量提升/","link":"","permalink":"xiexiaoge.github.io/2018/01/20/JS基础-变量提升/","excerpt":"","text":"变量提升 在当前作用域中js代码自上而下执行之前,浏览器首先会把所有带var/function关键字的进行提前声明或者定义 声明(declare): var num; 在当前作用域中定义一个名字 定义(defined): num=12;把声明的名字赋一个值 带 var 关键字的只是提前的声明一下; 带function关键字的在变量提升阶段把声明和定义都完成了 123456789example 1 var num =13;function fn()&#123; console.log(a)//undefined var a=10; console.log(a)//10&#125;fn();console.log(num);//13 定义变量的时候带 var 和不带var 的区别?&gt; [带var]- 在当前作用域中声明了一个变量,如果当前是全局作用域,也相当于给全局作用域设置了一个属性叫做a12345example 1 console.log(a) 报错 a is not defined a=12; console.log(a) //12 console.log(window.a)// 12&gt; [不带var]- 在全局作用域中,如果不带var,仅仅是给全局对象设置了一个新的属性名(把window.省略了)12345example 2 console.log(a) //undefined var a =12; console.log(a) //12 console.log(window.a)// 12以后项目中,如果是为了创建变量,最好不要省略var,这样会更加严谨一些作用域链 函数执行形成一个私有的作用域(可以保护私有变量),进入到私有作用域中,首先变量提升(声明过的变量是私有的),接下来代码执行 1.执行的时候遇到一个变量,如果这个变量是私有的,那么按照私有处理即可 123456789function fn()&#123; //=&gt;[私有作用域] //变量提升 var a;(私有变量) console.log(a);//undefined var a=12; console.log(a);//12&#125;;fn();console.log(a);// a is not defined 2.如果当前这个变量不是私有的,我们需要向它的上级作用域进行查找,上级如果也没有,则继续向上查找,一直找到window全局作用域为止,我们把这种查找机制叫做作用域链 1) 如果上级作用域有,操作的都是上级作用域中的变量(假如我们在当前作用域把值改了,相当于把上级作用域中的这个值给修改了) 2) 如果上级作用域没有这个变量(找到window也没有): 变量=值:相当于给window添加一个属性 以后在操作window下就有了 console.log(变量): 想要输出这个变量,如果这个变量没有的,所以会报错 1234567function fn()&#123; //console.log(a);//a is not defined a=12; console.log(a);//12&#125;;fn();console.log(a);//12 综合例子 12345678910111213example 1//=&gt;变量提升 var x; var y; fn=AAAFFF111;console.log(x, y);//undefined undefinedvar x=10,y=20;function fn() &#123; //=&gt;[私有作用域] //=&gt;变量提升:var x;(x是私有变量) console.log(x, y);//x undefined ,y 20 var x=y=100; // window.y=100 console.log(x, y);//x 100 y 100&#125;fn();console.log(x,y); //10 100 注意: 这里的 var x=y=100;=&gt;var x=100 ; y=100; 只有x是一个变量,y只是window下面的一个属性, 因为从右到左赋值 只对等号左边的进行变量提升 只对等号左边进行变量提升,右边是值,不会提前声明什么的; 我们创建函数的时候,可以使用函数表达式的方式: 因为只能对等号左边的进行变量提升,所以变量提升完成后,当前只是声明了,没有定义,想要执行函数,只能放在赋值的代码之后(放在前面执行相当于undefined执行,会报错) 这样让代码逻辑更加严谨,以后想要知道一个执行的函数做了什么功能,只需要向上查找定义的部分即可(不会存在定义的代码在执行下面的情况) 实名函数 1234567var fn=function sum () &#123; console.log(sum);//-&gt;函数本身 console.log(1); console.log(arguments.callee);//-&gt;函数本身&#125;;//sum()=&gt;报错 sum is not definedfn(); 不管条件是否成立都要进行变量提升 不管条件是否成立,判断体中出现的var/function都会进行变量提升,但是在最新版本浏览器中,function声明的变量只能提前声明不能定义了(前提:函数是在判断题体中)123456console.log(num, fn);//undefined,undefinedif(1!==1)&#123; var num=12; function fn()&#123; &#125;&#125; 代码执行的条件判断 [条件不成立]进入不到判断体中,赋值的代码执行不了,此时之前声明的变量或者函数依然是undefined [条件成立]进入条件判断体中的第一件事情不是代码执行,而是把之前变量提升没有定义的函数首先定义了(进入到判断体中函数就定义了;迎合ES6中的块级作用域)123456789console.log(num, fn);//undefined,undefinedif(1==1)&#123; console.log(num);//undefined console.log(fn);//函数体本身 var num=12; function fn()&#123; &#125;&#125; console.log(fn);//函数体本身 老版本浏览器不是这样处理的: 不管条件是否成立,都要进行变量提升(和新版本不一样的地方,新版本function只是声明,老版本function依然是声明+定义) 关于重名的处理 在变量提升阶段,如果名字重复了,不会重新的进行声明,但是会重新的进行定义(后面赋的值会把前面赋的值替换掉) 特殊变量提升的情况 = 右边不进行变量提升 自执行函数不进行变量提升 匿名函数当作参数的时候不进行变量提升 函数执行return后面的代码不执行但是需要变量提升,return出的代码执行但是不进行变量提升 if判断中的变量提升,不管条件是否成立都进行变量提升,新版本中var跟function都是只声明不定义,代码执行的时候,条件一旦成立,先给函数赋值,然后代码执行 let 和const 定义变量时,没有变量提升","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-数据类型的核心操作原理","slug":"JS基础-数据类型的核心操作原理","date":"2018-01-19T03:38:09.000Z","updated":"2018-01-20T08:08:49.400Z","comments":true,"path":"2018/01/19/JS基础-数据类型的核心操作原理/","link":"","permalink":"xiexiaoge.github.io/2018/01/19/JS基础-数据类型的核心操作原理/","excerpt":"","text":"js中的数据类型 基本数据类型(值类型) number string boolean null undefined 引用数据类型 对象 {} 普通对象 [] 数组 /^$/ 正则 函数 类 JS代码运行在浏览器中,是因为浏览器给我们提供了一个供js代码执行的环境-&gt;全局作用域(window/global) 1234567891011121314151617181920212223example 1 let a= 12;// 只是给变量a 赋值 让a 和12建立链接关系 let b= a; //b-&gt;a=12 b=13; //b=13 console.log(a); ***12***个人解析:只是把a的值赋值给b ,a和b还是独立的互不影响example 2 let o=&#123;name:\"小哥\"&#125;;//-&gt;o开辟了一个内存空间(aaafff111) let p=o;// -&gt; p=o-&gt;(aaafff111) p.name=\"小明\";// -&gt; aaafff111空间的name=\"小明\" console.log(o.name);// o.name-&gt;aaafff111.name-&gt;小明***小明***个人解析:因为引用数据类型,所以o,p指向地址aaafff111,p.name是堆内存中的name(后面的o,p都看成aaafff111去理解)example 3 let m=&#123;name:\"小哥\"&#125;;//-&gt;o开辟了一个堆内存(aaafff111) let n=m;//n=m-&gt;aaafff111 n=&#123;name:\"小明\"&#125;;// 这里的n 重新指向了新的地址,也就是n开辟了一个堆内存, 以后的 m和n就是独立的 console.log(m.name)个人解析:因为n重新指向了新的地址,所以以后的n和m都是独立的***小哥*** 值类型 直接按值操作,例如 let a=12;直接把12这个值赋值给变量a(让a变量和12这个值建立了链接关系) 对象数据类型 在JS中遇到对象,会严格按照如下的步骤操作: 浏览器为起开辟一个新的内存空间,为了方便后期可以找到这个空间,浏览器给空间分配一个16进行的地址(堆内存) 按照一定顺序,分别把对象键值对存储到内存空间中 把开辟内存的地址赋值给变量(或者其它的东西),以后变量就可以通过地址找到内存空间,然后进行一些操作 函数的操作 创建函数 开辟一个新的内存空间(为其分配一个16进制的地址) 把函数体中编写的js代码当作 字符串 存放到空间中(函数值创建不执行没有意义) 把分配的地址赋值给声明的函数名 执行函数 目的:执行函数体中的代码 函数执行的时候,浏览器会形成一个新的私有作用域(只能执行函数体中的代码)供函数体中的代码执行 执行代码之前,先把创建函数存储的那些字符串变为真正的js表达式,按照从上到下的顺序在私有作用域下执行 一个函数可以被执行N次,每一次执行相互之间互不干扰","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]}]}