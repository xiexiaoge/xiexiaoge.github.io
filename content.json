{"meta":{"title":"小哥","subtitle":"小哥","description":"个人笔记","author":"小哥","url":"xiexiaoge.github.io"},"pages":[{"title":"about","date":"2018-01-20T04:13:10.000Z","updated":"2018-01-20T08:13:22.493Z","comments":true,"path":"about/index.html","permalink":"xiexiaoge.github.io/about/index.html","excerpt":"","text":"刚写博客,可能内容不是很nice,但是希望自己能坚持,技术就像粥,越熬越有味!"}],"posts":[{"title":"JS基础-JSONP","slug":"JS基础-JSONP","date":"2018-01-30T16:30:18.000Z","updated":"2018-01-30T16:40:05.207Z","comments":true,"path":"2018/01/31/JS基础-JSONP/","link":"","permalink":"xiexiaoge.github.io/2018/01/31/JS基础-JSONP/","excerpt":"","text":"JSONP JSONP和AJAX相同 , 都是客户端想服务器端发送请求:给服务器端传递数据或者从服务器端获取数据的方式 AJAX属于同源策略 JSONP属于非同源策略(跨域请求) -&gt; 实现跨域请求的方式有很多 , 只不过JSONP是最常用的 区别同源和非同源 当前页面的地址&amp;&amp;数据请求的接口数据 协议 域名或者IP 端口号 JSONP的原理(JSONP请求一定需要对方的服务器做支持才可以) 在SCRIPT的世界中 , 没有同源跨域这一说 , 只要SRC属性中的地址是一个合法的地址 , srcipt都可以把对应的内容请求回来 JSONP就是利用了SCRIPT的这个原理 首先把需要请求数据的那个跨域API数据接口的地址赋值给SCRIPT的SRC 把当前页面中的某一个函数名当作参数值传递给需要跨域请求数据的服务器(URL问号传参) 服务器接收到请求后 , 需要进行特殊的处理 : 把传进来的函数名和它需要给的数据拼接成一个字符串(例如:传进去的函数名字是Fn 它准备好的数据是 fn([“name”:”xxxx”]))-&gt;传递的函数名(服务器需要给数据做处理) 服务器把准备的数据通过http协议返回给我们的客户端 , 客户端发现其实就是fn执行 , 而且还给fn传递了一堆数据,哪些数据就是我们想要的了","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"Interview questions","slug":"Interview-questions","permalink":"xiexiaoge.github.io/tags/Interview-questions/"}]},{"title":"JS基础-存储","slug":"JS基础-存储","date":"2018-01-30T16:13:10.000Z","updated":"2018-01-30T16:20:36.880Z","comments":true,"path":"2018/01/31/JS基础-存储/","link":"","permalink":"xiexiaoge.github.io/2018/01/31/JS基础-存储/","excerpt":"","text":"loaclStorage,cookie,sessionStorage 本地存储 把一些信息存储在当前浏览器 指定域下的某一个地方(存储到物理硬盘中) 在谷歌浏览器中存储的信息,在IE浏览器中无法获取 , 因为本地存储是存在当前浏览器中的某个位置的 不能跨域传输 : 在京东下存储的信息 , 在淘宝域下不能获取到(也是为了保证信息的安全性) 本地存储并不安全 , 可以可到每个浏览器存储信息的位置 , 然后把信息进行解码编译 , 导致客户端一些存储的信息泄露 cookie webStorage : loaclStorage sessionStorage IndexedDB WebSQL Cache Stroage …. 服务器存储 把信息存储在指定的服务器中(真实项目中大部分都是基于服务器进行存储的) session 服务器端数据库存储 服务器端缓存存储 localStorage VS sessionStorage 他们都是H5中新增加的API(不兼容低版本浏览器 , 常应用于移动端开发) loaclStorage : 本地永久存储(只要不手动删除 , 本地就存储着) sessionStroage : 本地会话存储 , 当前页面关闭 , 代表着会话结束 , 会把存储的信息自动清除(刷新页面不会清除) 都支持下一使用方法 : setItem([key],[value]) : 通过键值对的方式把信息存储在客户端本地(存储在本地的信息值都是字符串格式的) getItem([key]) : 获取本地存储信息中指定属性名的属性值 removeItem([key]) : 把本地存储信息中指定属性名的信息删除掉 clear() : 把本地存储的信息都删除掉(清空: 只能清空当前浏览器自己域下的信息) key([index]) : 本地存储的信息是有一定的顺序的(一般都是按照存储的先后顺序) , 我们可以把所有存储的信息理解为一个信息集合 , key就是通过索引获取这个集合中指定位置的属性名信息的 loaclStorage VS cookie cookie 是一个非常常用的本地存储方式 , 在没有loaclStorage之前 , 基本上使用的都是cookie 关于兼容问题 cookie兼容所有浏览器 loaclStorage IE6~8不兼容 项目中PC端开发 , 如果需要存储的信息比较重要(例如: 登录信息 , 购物车信息等) , 需要兼容的,只能用cookie , 其余不需要考虑兼容的 , 根据需求自己选择 时效性 cookie有过期时间(可以自己设置 , 一般都不会设置很长) loaclStorage没有过期时间 , 只要自己不手动清除 , 永久存储在本地 使用360等安全位置清理垃圾的时候 , 或者使用浏览器自带的清理工具的时候 , 都极有可能会把本地存储的cookie都干掉 , 但是目前是干不掉loaclStorage存储的信息的 用户可能出于安全角度 , 禁止记录cookie , 例如浏览器的无痕浏览器模式或者隐私模式 存储大小 cokkie允许一个域下最多可以存储4kb左右的内容 localStorage允许一个域下最多可以存储 5 MB左右的内容项目中基于本地存储 , 存储的信息量不会特别多(使用loaclStorage存储的可能还多一些) , 大量的信息都需要基于服务器进行存储 处理机制 cookie不是完全的本地存储 , 在我们使用cookie的时候 , 需要客户端和服务器端进行相关的通信处理(cookie总会在客户端和服务器端来回进行传输) loaclStorage是完整的本地存储 , 和服务器端没有半毛线关系 安全性 不管cookie还是loaclStorage都是本地明文存储 , 控制台 - &gt; Application 可以看到存储的内容 重要的信息不建议在本地进行存储(例如 : 用户名 , 密码 , 手机等) , 如果非要存储 , 一定要做好加密工作","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"Interview questions","slug":"Interview-questions","permalink":"xiexiaoge.github.io/tags/Interview-questions/"}]},{"title":"JS基础-AJAX同步异步","slug":"JS基础-AJAX同步异步","date":"2018-01-29T17:43:54.000Z","updated":"2018-01-29T17:45:56.925Z","comments":true,"path":"2018/01/30/JS基础-AJAX同步异步/","link":"","permalink":"xiexiaoge.github.io/2018/01/30/JS基础-AJAX同步异步/","excerpt":"","text":"AJAX同异步 AJAX这个任务 : 发送请求接收到响应主体内容(完成一个完整的HTTP事物) xhr.send();任务开始 xhr.readyState===4 ; 任务结束 同步 异步 JQ中的AJAX 1234567891011121314$.ajax(&#123; url:\"xxx\",//=&gt;请求API地址 method:\"get\",//=&gt;设置请求方式 GET/POST ...在老版本JQ中使用的是TYPE , 使用type和method实现的是相同的效果 dataType:\"json\",//=&gt; dataType 只是我们预设获取结果的类型 , 不会影响服务器的返回 (服务器端一般给我们返回的都是JSON格式字符串) , 如果我们预设的是JSON , 那么类库中将把服务器返回的字符串转换为JSON对象 , 如果我们预设的是text(默认值) , 我们把服务器获取的结果直接把过来操作即可 , 我们预设的值还可以是XML等 cache :false //=&gt;设置是否清除缓存 , 只对GET系类请求有作用 , 默认是true不清缓存,手动设置为false , JQ库会在请求URL的末尾追加一个随机数来清除缓存 data:null //=&gt;通过data可以把一些信息传递给服务器;get系列请求会把data中的内容拼接在url的末尾通过问好传参的方式传递给服务器,post系列请求会把内容放在请求主体中传递给服务器;DATA的值可以设置为两种格式:字符串,对象,如果是字符串,设置的值是什么传递给服务器的就是什么,如果设置的是对象,JQ会把对象变为 xxx=xxx&amp;xxx=xxxx 这样的字符串传递给服务器 async : true //=&gt;异步 success:function(result)&#123; //=&gt;当ajax请求成功 (readyState===4&amp;&amp;status是以2或者3开头的) //=&gt;请求成功后JQ会把传递的回调函数执行,并且把获取的结果当做实参传递给回调函数(result就是我们从服务器端获取的结果) &#125; error:function(msg)&#123;&#125;,//=&gt;请求错误触发回调函数 complate:function()&#123;&#125;;//=&gt;不管请求是错误的还是正确的都会触发回调函数&#125;)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-http和ajax","slug":"JS基础-http和ajax","date":"2018-01-29T17:28:42.000Z","updated":"2018-01-29T17:43:10.593Z","comments":true,"path":"2018/01/30/JS基础-http和ajax/","link":"","permalink":"xiexiaoge.github.io/2018/01/30/JS基础-http和ajax/","excerpt":"","text":"http和ajax 客户端和服务器端是如何通信的 Request 请求阶段 首先根据客户端输入的域名 , 到DNS服务器上进行反解析(通过域名找到对应服务器的外网IP) 通过找到的外网 IP , 找到对应的服务器 通过在地址栏中输入的端口号(没有输入是因为不同协议有自己默认端口号)找到服务器上发布的对应的项目 Response 响应阶段 服务器获取到请求资源文件的地址 , 把资源文件中的源代码找到 服务器端会把找到的源代码返回给客户端(通过http等传输协议返回的) 浏览器自主渲染 客户端接收到原代码后 , 会交给浏览器的内核(渲染引擎)进行渲染 , 最后由浏览器绘制出对应的页面 一个完整的URL地址https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=aiqiyi%20&amp;rsv_pq=ddb25cd2000036f8&amp;rsv_t=dff5bJQMRv6D1whsBDgrVvoa1krqRBQJJuFQ60iiZBnAC%2BfW64poKCEX8e0&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=7&amp;rsv_sug1=5&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=1562&amp;rsv_sug4=1562 第一部分 : 传输协议 传输协议用来完成客户端和服务器端的数据(内容)传输的 客户端不仅可以向服务器发送请求 , 而且还可以把一些内容传递给服务器 服务器也可以把内容返回给客户端 客户端和服务器端传输的内容总称HTTP报文,这些报文信息都是基于传输协议完成传输的 , 客户端传递给服务器叫做请求 , 服务器返回给客户端叫做响应 传输协议分类 http : 超文本传输协议(客户端和服务器端传输的内容除了文本以外,还可以传输图片, 音频等文件流,以及传输xml格式的数据等) https : 它比http更加安全 , 因为数据内容的传输通过是经过ssl加密的(它需要在服务器端进行特殊的处理) , 所以涉及资金类的网站一般都是https协议的 ftp : 资源文件传输协议 , 一般用于客户端把资源文件(不是代码) 上传到服务器端 , 或者从服务器端下载一些资源文件 客户端传递给服务器端数据 url 问号传参 设置请求头 设置请求主体 服务器返回给客户端内容 设置响应头(例如服务器时间) 设置响应主体 HASH值 页面中的锚点定位 前端路由(SPA单页面开发) AJAX 异步的JS 这里的异步不是说AJAX只能基于异步进行请求,这里的异步指的是局部刷新 可以根据需求 , 任意修改页面中某一部分的内容(例如实时刷新) , 整个页面不刷新 , 性能好 , 体验好(所有表单验证 , 需要实时刷新的等需求都要基于ajax实现) 有利于开发 , 提高开发效率(可以同时进行开发 (写好接口)) 基于原生JS实现AJAX 123456789101112 //=&gt;创建一个AJAX对象 let xhr = new XMLHttpRequest(); //=&gt;打开请求地址(可以理解为一些基础配置,但是并没有发送请求) xhr.open([method],[url],[async],[user.name],[user.password]) //=&gt;监听AJAX状态变化,获取响应信息(获取响应头信息,获取响应主体信息) xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState===4&amp;&amp;xhr.status===200)&#123; let result=xhr.responseText;//=&gt;获取响应主体的内容 &#125;&#125;//=&gt;发送ajax请求(括号中传递的内容就是请求主体的内容)xhr.send(null) 分析第二步中的细节点 xhr.open([method],[url],[async],[user.name],[user.password]) GET系列的请求(获取)getdelete 从服务器上删除某些资源head 只想获取服务器返回的响应头信息(响应主体内容不需要获取) POST系列的请求(推送)postput : 想服务器中增加指定的资源文件 不管哪一种请求方式,客户端的都可以把信息传递给服务器,服务器也可以把信息返回给客户端,只是GET系列一般以获取为主(给的少,拿回来的多),而POST系列一般以推送为主(给的多,拿回来的少) 我们想过去一些动态展示的信息,一般使用GET请求 , 因为只需要向服务器端发送请求 , 告诉服务器想要什么, 服务端就会把需要的数据返回 在实现注册功能的时候, 我们需要把客服输入的信息发送给服务器进行存储 , 服务器一般返回成功还是失败等状态 , 此时我们一般都是基于POST请求完成 GET系列请求和POST系列请求 , 在项目实战中存在很多的区别 GET请求传递给服务器的内容一般没有POST请求传递给服务器的内容多 GET请求传递给服务器内容一般都是基于URL问号传递参数来实现的,而POST请求一般是基于设置请求体来实现的. 各浏览器都有自己URL最大长度的限制(谷歌: 8KB , 火狐 : 7KB , IE : 2KB…)超过限制长度的部分,浏览器会自动截取掉,导致传递给服务器的数据缺失 POST请求通过请求主体传递是诶有大小限制的 , 真实项目中为了保证传输的速率 , 也会限制大小(上传图片资料等) GET请求很容易出现缓存(这个缓存不可控:一般都不需要);POST不会出现缓存 GET是通过URL问号传参传递给服务器信息,而POST是设置请求主体 设置请求主体不会出现缓存 , 但是URL传递参数就会了 GET请求没有POST请求安全(也并不是十分安全) 原因 : GET是URL传参 URL劫持 , 导致信息泄露 AJAX状态码和网络状态码 123456 //=&gt;监听AJAX状态变化,获取响应信息(获取响应头信息,获取响应主体信息) xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState===4&amp;&amp;xhr.status===200)&#123; let result=xhr.responseText;//=&gt;获取响应主体的内容 &#125;&#125; AJAX状态码 : 描述当前AJAX操作的状态的 (xhr.readyState) 0 . UNSENT 未发送 , 只要创建一个AJAX对象 , 默认值就是零 1. OPENED 我们已经执行了xhr.open这个操作 2 . HEADERS_RECEIVED 当前AJAX的请求已经发送 , 并且已经接受到服务器端返回的响应头信息了 3 . LOADING响应主体内容正在返回的路上 4 . DONE响应主体内容已经返回到客户端 HTTP网络状态码 : 记录了当前服务器返回信息的状态 xhr.status 200 : 成功 , 一个完整的HTTP事务完成(以2开头的状态码一般都是成功) 以3开头的一般也是成功 , 只不过服务器做了很多特殊的处理 301 : 永久转移 (永久重定向) 一般应用于域名迁移 302 : 临时转移 (临时重定向 , 新的HTTP版本钟任务307是临时重定向) 一般用于服务器的负载均衡 , 当前服务器处理不了,我把当前请求临时交给其他服务器处理(一般图片请求经常出现302,很多公司都有单独的图片服务器) 304 : 从浏览器缓存钟获取数据把一些不经常更新的文件或者内容缓存在浏览器中,下次从缓存中获取,减轻服务器压力 , 也提供页面加载速度 以4开头的 , 一般都是失败 , 而且客户端的问题偏大 400 : 请求参数错误 403 : 无权限访问 404 : 访问地址不存在 以 5 开头的 , 一般都是失败,而且服务器的问题偏大 500 : 未知的服务器错误 503 : 服务器超负载 常用的AJAX属性和方法 let xhr = new XMLHttpRequest(); console.dir(xhr) 属性 readyState : 存储的是当前AJAX的状态码 response / responseText / responseXML : 都是用来接收服务器返回的响应主体中的内容 , 只是根据服务器返回内容的格式不一样 , 我们使用不同的属性接受即可 responseText是最常用的 , 接收到的结果是字符串格式的(一般服务器返回的数据都是JSON格式字符串) responseXML偶尔会用到 , 如果 服务器返回的是XML文档数据 status : 记录了浏览器返回的HTTP状态码 statusText : 对返回状态码的描述 timeout : 设置当前AJAX请求的超时事件 , 假设我们设置事件为 3000MS , 从AJAX请求发送开始 , 3秒后响应主体内容还没有返回 , 浏览器会把当前AJAX请求任务强制断开 方法 abort() : 强制中断AJAX请求 getAllResponseHeaders() ; 获取全部的响应头信息(获取的结果是一堆字符串文本) getAllResponseHeaders(key) : 获取指定属性名的响应头信息 , 例如 : xhr.getResponseHeader(date)获取响应头中存储的服务器的时间 open() : 打开一个URL地址 overrideMimeType() : 重写数据的MIME类型 send() : 发送AJAX请求(括号中书写的内容是客户端基于请求主体把信息) setRequestHeader(key,value) : 设置请求头信息(可以是设置的自定义请求头信息) 事件 onabort : 当AJAX被中断请求触发这个事件 onreadystatechenge : AJAX状态发生改变 , 会触发这个事件 ontimeout : 当AJAX请求超时 , 会触发这个事件 JS中常用的编码解码方法 正常的编码解码(非加密) escape /unescape : 主要就是把中文汉字进行编码和解码的(一般只有JS语言支持 : 也经常应用于前端页面通信时候的中文汉字编码)也可以通过加密的方法进行编码解码 encodeURL / decodeURL : 基本上所有的编程语言都支持 encodeURLComponetn / decodeURLComponent 需求 : URL 问号传参的时候 , 传递的参数值还是一个URL或者包含很多特殊的字符 , 此时为了不影响主要的URL , 我们需要把传递的参数值进行编码 . 使用encodeURL不能编写一些特殊字符 , 所以只能使用 encodeURLComponent处理","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-常见的性能优化","slug":"JS基础-常见的性能优化","date":"2018-01-29T17:23:34.000Z","updated":"2018-01-29T17:27:24.218Z","comments":true,"path":"2018/01/30/JS基础-常见的性能优化/","link":"","permalink":"xiexiaoge.github.io/2018/01/30/JS基础-常见的性能优化/","excerpt":"","text":"WEB前端开发常用的优化技巧 减少HTTP请求的次数或者减少请求数据的大小 页面中每发送一次http请求 , 都需要完成请求+响应这个完整的http事务,会消耗一些时间, 也可能会导致http链接通道的堵塞 , 为了提高页面加载速度和运行的性能 , 我们应该减少HTTP请求次数和减少请求内容的大小 采用CSS雪碧图,把一些小图合并在一张大图上,使用的时候通过背景图片定位,定位到具体的某一张小图上 合并压缩 CSS或者JS文件(例如 : webpack) 把合并后的CSS或者JS压缩成xxx.min.js 减少文件大小,服务器端开启资源文件GIF压缩通过一些自动化工具完成CSS以及JS的合并压缩 , 或者再完成LSEE转CSS , ES6转ES5等操作 , 这种自动化构建模式 , 称之为前端 “工程化”开发 采用图片懒加载技术 , 在页面开始加载的时候 , 不请求真实的图片地址 , 而是用默认图占位 , 当页面加载完成后 , 在根据相关的条件衣服加载真实图片 (减少页面首次加载HTTP请求的次数) 开始加载页面的时候 , 我们只把首屏或者前两屏的数据从服务器端进行请求(有些网站首屏数据是后台渲染好 , 整体返回给客户端呈现的) 当页面下拉 , 滚动到哪个区域 , 在把这个区域需要的数据进行请求(请求回来做数据绑定以及图片延迟加载等) 分页展示技术采用的也是数据的懒加载思想实现的 对于不经常更新的数据 , 最好采用浏览器的304缓存做处理(主要由服务器端处理) 第一次请求CSS和JS下来 , 浏览器会把请求的内容缓存起来 , 如果做了404处理 , 用户再次请求CSS和JS , 直接从缓存中读取 , 不需要再去服务器获取了(减少HTTP请求次数) 当用户强制刷新页面或者当前缓存的CSS或者JS发生了变动 ,都会从新从服务器端拉取 对于客户端,可以基于loaclStroage来做一些本地存储 , 例如:第一次请求的数据或者不经常更新的CSS和JS , 我们都可以把内容存储在本地 , 下一次页面加载,我们从本地中获取即可,设定一定的期限或者一些标识 , 我们控制在某个阶段重新从服务器获取 使用字体图标代替一些页面中的位图,这样不仅做适配的时候方便 , 而且更加轻量级 , 而且减少了http请求次数 如果当前页面中出现了audio或者video,我们最好设置它们的preload=node 页面加载的时候 , 音视频不进行加载 , 播放的时候再开始加载 preload=auto 页面首次加载的时候就把音视频资源进行加载了 preload=metadata 页面首次加载的时候只把音视频资源的头部信息进行加载 在客户端和服务器端进行数据通信的时候 , 我们进来采用JSON格式进行数据传输 JSON格式的数据 , 能够清晰明了的展示出数据结构,而且也方便我们自己获取和操作 JSON格式的数据更加轻量级 客户端和服务器都支持JSON格式数据的处理 , 处理起来非常的方便 并不是所有的数据都需要基于JSON , 特殊需求特殊处理(例如 : 文件流的传输或者文件传输) 关于编写代码时候的一些优化技巧 除了减少HTTP请求次数和大小可以优化性能 , 我们在编写代码的时候 , 也可以进行优化 , 让页面性能有所提升 在编写代码的时候 , 尽量减少对DOM的操作 在JS中操作DOM是一个非常消耗性能的事 , 但是我们又不可避免的操作DOM , 我们只能尽量减少对于它的操作 DOM存在映射机制(JS中的DOM元素对象和页面中的DOM结构事存在映射机制的 , 一改则都改) , 这种映射机制, 是浏览器按照W3C标准完成对JS语言的构建和DOM的构建(其实就是构建了一个监听机制),操作DOM是同时要修改两个地方,相对于一些其它的JS编程来说是消耗性能的 页面中的DOM结构改变或者样式的改变 , 会触发浏览器的回流(浏览器会把DOM结构重新进行计算,这个操作很耗性能)和重绘(把一个元素的样式重新渲染) 编写代码的时候 , 更多的使用异步编程 同步编程会导致 : 上面东西完不成 , 下面任务也做不了 , 我们开发的时候 , 可以把某一个区域模块都设置为异步编程 , 这样只要模块之间没有什么必然的先后顺序 , 都可以独立进行 , 不会收到上面模块的堵塞影响 尤其是Ajax数据请求 , 我们一般都要使用异步编程 , 最好使用 promise设计模块进行管理(项目中经常使用fetch , vue , axios等插件来进行AJAX请求处理 , 因为这些插件中就是基于promise设计模式对ajax进行的封装处理) CSS选择器优化 尽量减少标签选择器的时候 尽量减少使用ID选择器 , 多使用样式类选择器(通用性强) 减少选择器前面的前缀 避免使用CSS表达式 减少页面中的冗余代码 , 尽可能提高方法的重复使用率: “低耦合高内聚” 最好CSS放在HEAD中 , JS放在BODY尾部 , 放页面加载的时候 , 先加载CSS , 再加载JS(先呈现页面, 在给用户提高操作) JS中避免使用eval 性能消耗大 代码压缩后, 容易出现代码执行错乱问题 JS中尽量减少闭包的使用 闭包会形成一个不销毁的栈内存 , 过多的栈内存累积会影响页面的性能 还会容易导致内容的泄露 在做DOM事件绑定的时候 , 尽量避免一个个的绑定事件,而是采用性能更高的事件委托来实现 事件委托(事件代理) 把事件绑定给外层容器 , 当里面的后代元素相关行为触发 , 外层容器绑定的方法也会触发执行(冒泡传播机制导致) , 通过事件源是谁 , 我们做不同的操作即可 尽量使用CSS动画代替JS动画 , 因为CSS3的动画或者变形都开启了硬件加速 , 性能比JS动画好 编写JS代码的时候尽可能使用设计模式来构建体系 , 方便后期的维护 , 也提高了扩充性等 关于页面的SEO优化技巧 页面中杜绝出现死链接(404页面) , 而且对于用户输入一个错误页面 , 我们要引导到404提示页面中(服务器处理的) 避免浏览器中异常错误的抛出 使用try catch 做异常信息捕获 增加页面关键词优化","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"Interview questions","slug":"Interview-questions","permalink":"xiexiaoge.github.io/tags/Interview-questions/"}]},{"title":"JS基础-DOM0VSDOM2","slug":"JS基础-DOM0VSDOM2","date":"2018-01-29T17:13:04.000Z","updated":"2018-01-29T17:21:58.097Z","comments":true,"path":"2018/01/30/JS基础-DOM0VSDOM2/","link":"","permalink":"xiexiaoge.github.io/2018/01/30/JS基础-DOM0VSDOM2/","excerpt":"","text":"DOM0事件绑定和DOM2事件绑定的区别 DOM0事件绑定的原理 给当前元素对象的某一个私有属性(onxxx)赋值的过程 (之前属性默认值是null,如果我们给赋值一个函数,就相当于绑定了方法) 当我们赋值成功(函数) , 此时浏览器会自动把DOM元素和赋值的函数建立关联 ,以及建立DOM元素行为操作监听,当某一个行为被用户触发,浏览器会把相关行为赋值的函数执行 特点 12345678910111213141516171819//=&gt;1.只有DOM元素天生拥有这个私有属性(onxxx事件私有属性),赋值的方法才叫做事件绑定,否则属于给当前元素设置一个自定义属性而已document.body.onclick=function()&#123;&#125;;//=&gt;事件绑定手动点击页面中的BODY触发方法执行domcument.body.onclick()这样执行也可以document.body.onxxx=function()&#123;&#125;;//=&gt;设置自定义属性domcument.body.onxxx()这样执行可以//=&gt;2. 移除事件绑定的时候,我们只需要赋值为null即可document.body.onclick=null;//=&gt;3. 在DOM0事件绑定中,只能给当前元素的某一个事件行为(某一个事件私有属性)绑定一个方法,绑定多个方法,最后一次绑定的会把之前绑定的都替换掉document.body.onclick=function()&#123; console.log(1)&#125;document.body.onclick=function()&#123; console.log(2)&#125;//=&gt;点击body只能输出2,因为第二次赋值的函数把第一次赋值的函数给替换了 DOM2事件绑定的原理 DOM2事件绑定使用的addEventListener/attachEvent都是在EventTarget这个类内置类的原型上定义的 , 我们调取使用的时候,首先通过原型链找到这个方法,然后执行完成事件绑定的效果 浏览器首先会给当前元素的某一个事件行为开辟一个事件池(事件队列)[其实是浏览器有一个统一的事件池,我们每一个元素的某个行为绑定的方法都放在这个事件池中,只是通过相关的标识来区分的] , 当我们通过addEventListener做事件监听的时候 , 会把绑定的方法存放在事件池中 当元素的某一个行为触发 , 浏览器会对应到事件池中,把当前存放在事件池中的所有方法,依次按照存放的先后顺序执行 特点:12345678910111213141516171819202122232425//=&gt;1. 所有DOM0支持的事件行为 , DOM2都可以使用,不仅如此,DOM2还支持一些DOM0没有的事件行为 : DOMContentLoaded... document.body.onDOMContentLoaded===undefined;//=&gt;DOM0中没有这个属性document.body.addEventListener(\"DOMContentLoaded\",function()&#123; //=&gt;标准浏览器中兼容这个事件:当浏览器中的DOM结构加载完成,就会触发这个事件(也会把绑定的方法执行)&#125;,false) //=&gt;2. DOM2中可以给当前元素的某一个事件行为绑定\"多个不同的方法\"(因为绑定的所有方法都存在事件池中了) function fn1()&#123; console.log(1)&#125; function fn2()&#123; console.log(2)&#125; function fn3()&#123; console.log(3)&#125;document.body.addEventListener(\"click\",fn1,false);document.body.addEventListener(\"click\",fn3,false);document.body.addEventListener(\"click\",fn2,false);document.body.addEventListener(\"click\",fn3,false);//=&gt;本次向事件池中存储的时候 , 发现fn3已经在事件池存在了 , 不能再存储了// 3.DOM2事件绑定的移除,比较麻烦一些,需要和绑定的时候:事件类型,绑定的方法,传播阶段,三个完全一致蔡可以移除掉document.body.removeEventListenter(\"click\",fn2,false);//=&gt;DOM2事件绑定方法的时候尽量不用匿名函数,为后期可能会把方法再事件池中移除掉做准备 DOM0和DOM2绑定的方法是毫无关系的(因为是两套不同的处理机制),即使绑定的方法相同,也是执行两次谁先绑定的, 就先执行谁 DOM2事件绑定的兼容处理 语法上的兼容 标准curELe.addEventListener(&quot;type&quot;,function,false) IE6~8curELe.attachEvent(&quot;type&quot;,function,false) 除了语法上的区别 , 在处理的机制上有一些区别 在IE6~8中使用attacEvent做事件绑定(把方法存放在当前元素指定事件类型的事件池中) 顺序问题 : 当事件行为触发,执行对应事件池中存放的方法的时候,IE低版本浏览器执行方法的顺序是乱序的(标准浏览器是按照绑定的先后顺序依次执行的) 重复问题 : IE低版本浏览器在向事件池中增加方法的时候,没有去重机制,哪怕当前方法已经存放过了,还会重复的增加进去(标准浏览器的事件池机制很完善,可以自动去重:已经存在过的方法不允许在添加进来) this问题 : IE低版本浏览器中,当事件行为触发,把事件池中方法执行,此时方法中的this指向window,而不是像标准浏览器一样,指向当前元素本身 其实都是IE低版本浏览器对它内置事件池处理机制的不完善导致的DOM2事件兼容处理的原理 : 告别IE6~8内置事件池,而是自己创建一个类似于标准浏览器的”自定义事件池”","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-事件冒泡,委托","slug":"JS基础-事件冒泡-委托","date":"2018-01-29T17:04:41.000Z","updated":"2018-01-31T15:26:12.692Z","comments":true,"path":"2018/01/30/JS基础-事件冒泡-委托/","link":"","permalink":"xiexiaoge.github.io/2018/01/30/JS基础-事件冒泡-委托/","excerpt":"","text":"事件的传播机制- 三个阶段处理的事情当前元素的某个事件行为被触发,它所有的祖先元素(一直到document)相关事件行为也会依次触发(顺序:从内向外),如果祖先元素的这个行为绑定了方法,绑定的方法也会被触发执行,我们把事件的这种传播机制叫做:&quot;冒泡传播&quot;事件委托 利用事件的冒泡传播机制完成(mouseenter不存在委托机制,因为它不存在冒泡传播) 一个容器中很多元素的同一个事件行为都要绑定方法,此时我们没有必要在获取所有元素,一个个的绑定方法了,我们只需要给最外层元素的这个事件绑定一个方法,这样不管里面哪一个元素的这个事件行为被触发,都会利用冒泡传播机制,把外层容器绑定的那个方法执行,在方法执行的时候,我们可以根据事件源判断出操作的是哪个元素,从而做不同的事件(使用事件委托这样完成的操作一个个的单独事件绑定性能提高50%左右)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-DOM事件","slug":"JS基础-DOM事件","date":"2018-01-29T16:52:51.000Z","updated":"2018-01-31T15:17:11.642Z","comments":true,"path":"2018/01/30/JS基础-DOM事件/","link":"","permalink":"xiexiaoge.github.io/2018/01/30/JS基础-DOM事件/","excerpt":"","text":"JAVASCRIPT中的事件基础及核心原理以及项目实战 事件基础 : 全新认识事件 什么是事件?事件是元素天生自带的行为方式(和写不写JS代码没关系),当我们去操作元素的时候会触发元素的很多事件 事件绑定给当前元素的某一个事件绑定方法 , 目的是为了让当前元素某个事件被触发的时候,可以做一些事情 给某一个事件绑定方法 , 目前常用的有两种方式: DOM0级事件绑定oBox.onclick=function(){} DOM2级事件绑定oBox.addEventListener(&quot;click&quot;,function),false标准浏览器oBx.addtachEvent(&quot;onclick),function(){} IE6~8 元素常用事件汇总 1234567891011121314151617181920212223242526272829&gt; `PC端`&gt; 表单元素常用的事件行为&gt; blur : 失去焦点时&gt; focus : 获取焦点&gt; change : 内容改变&gt; select : 被选中事件&gt; &gt; 键盘常用事件行为&gt; keydown 键盘按下&gt; keyup 键盘抬起&gt; keypress 键盘按下后有keypress(中文输入法状态下,会触发keydown,但是由于内容没有放在文本框中keypress没有被触发)&gt; &gt; 鼠标常用事件行为&gt; click : 点击(不是单击)&gt; dbclick : 双击 (300MS连续触发两次点击事件这样为双击事件)&gt; mouseover : 鼠标滑过&gt; mouseout : 鼠标离开&gt; mouseenter : 鼠标进入&gt; mouseleave : 鼠标离开&gt; mousemouve : 鼠标移动&gt; mousedown : 鼠标左键按下&gt; mouseup : 鼠标左键抬起&gt; mousewheel : 鼠标滚轮滚动&gt; 其它常用的事件行为:&gt; load : 加载成功&gt; error : 加载失败&gt; scroll : 滚轮滚动事件&gt; resize : 大小改变事件 window.onersize当浏览器窗口大小发生改变触发这个事件 移动端 移动端的键盘一般都是虚拟键盘,虽然部分手机存在keydown/keyup但是兼容不好,所以我们想要键盘事件的时候,使用input事件代替 移动端没有鼠标,所以鼠标类的事件在移动端兼容都特别差(mousexxx这些事件都不能用) 移动端的大部分操作时靠手指完成的,移动端独有手指事件 单手指事件模型 : touchstart touchmove touchend touchcancel 多手指事件模型 : getSturestart , getSturechange , gestureend… 移动端还有很多操作时基于手机硬件完成的 , 例如: 手机传感器 , 手机陀螺仪,手机重力感应器等 在移动端兼容click事件,pc端的click时点击,但是移动端把click事件当作单击: 移动端使用click事件处理点击操作存在300MS延迟 事件对象 1234//=&gt;事件绑定 : 给oBox的click事件,基于DOM0级事件绑定方法,绑定一个方法;以后当我们手动触发oBox的click行为的时候,会把绑定的方法执行; oBox.onclick=function(e)&#123; //=&gt;arguments[0]===e; 当方法执行的时候,浏览器默认传递给方法的参数值(事件对象)&#125; 当元素的某一个事件行为被触发,不仅会把之前绑定的方法执行,而且还会给当前绑定的方法传递一个值(浏览器默认传递的),我们把传递的这个值称为事件对象; 因为这个值时对象类型的值 , 里面存储了很多的属性和方法 这个对象中存储的值都是当前操作的一些基本信息,例如 : 鼠标的位置 , 触发的行为类型 , 触发的事件源等 以上所说都是针对标准浏览器 , IE6~8下不是这样的机制 IE6~8方法被触发执行的时候 , 浏览器并没有把事件对象当作值传递给函数(e在IE6~8下是undefined); 但是IE6~8也有事件对象,事件对象需要我们通过window.event单独获取 1234oBox.onclick=function(e)&#123; //=&gt;以后想要获取事件对象写两套 e=e||window.event;&#125; 事件对象是为了记录当前本次操作基本信息的 , 所以只和本次操作有关 : 本次操作,页面中不管通过什么方式获取的e或者window.event(也不管在哪获取的),他们存储的基本信息应该是相同的 鼠标事件对象 MouseEvent clientX/clientY : 当前鼠标出发点距离当前窗口左上角的X/Y轴坐标 pageX/pageY : 当前鼠标出发点距离body左上角的X/Y轴坐标(页面第一屏幕左上角 ) , 但是IE6到8中没有这两个属性 type : 当前触发事件的类型 target : 事件源(当前鼠标操作的是哪一个元素,那么事件源就是谁),IE6~8下没有target这个属性,它有的是srcElement这个属性代表事件源 preventDefault : 此方法是为了阻止事件的默认执行, IE6~8下没有这个方法,需要使用 e.returnVaule=false来处理 stopPropagation : 此方法是为了阻止事件的冒泡传播, IE6~8不兼容,需要使用 e.cancelBubble=true处理 移动端手指对象 TouchEvent touches :只有手指在屏幕上我们才可以获取对应的信息值(手指离开屏幕没有相关信息了,这样touchend事件中我们无法通过touches获取手指信息) changedTouches : 手机在屏幕上的时候,和touches获取的信息一样,但是他可以记录手指离开屏幕一瞬间所在的位置信息(最常用) 1234567891011TouchEvent type:类型 target:事件源 touches: 0:&#123; clientX:xxx, clientY:xxx, pageX:xxxx, pageY:xxx ... &#125; fastclick.js 目的就是为了解决移动端click事件300MS延迟的问题(如果我们的移动端使用了click事件,我们只需要把这个JS导入配置一下即可) 百度云touch手势事件库 hammer.js zepto.js 提供了移动端事件操作的模块 , 也是目前市场上使用率最高的(小型的JQ) 12345678910111213141516171819 $(\".box\").tap(function()&#123; //=&gt;单击&#125;) $(\".box\").doubleTop(function()&#123; //=&gt;双击&#125;) $(\".box\").longTap(function()&#123; //=&gt;长按&#125;) $(\".box\").swipe(function()&#123; //=&gt;滑动 swipeLeft/swipeRight/swipeUp/swipeDown&#125;) $(\".box\").pinchIn(function()&#123; //=&gt;缩小&#125;) $(\".box\").pinchOut(function()&#123; //=&gt;放大&#125;) A标签的默认行为及阻止 A标签都有哪些默认行为 超链接 : 点击A标签可以实现页面的跳转 锚点定位: 通过 HASH(哈希)值定位到当前页面指定ID元素的位置 (元素的ID和哈希值相同的位置) 首先在URL地址栏的末尾追加一个HASH值 如果地址中有HASH值,浏览器除了页面渲染外,在渲染完成后,会默认定位到指定HASH值的元素位置 真实项目中我们想用A标签做一个普通的按钮(优势 : 他的 :hove样式是兼容所有浏览器的) , 此时就要把之前提到的两个默认执行阻止掉才可以 阻止A标签的默认行为 12345678910111213//=&gt;在HTML中阻止默认行为 (最常用)&lt;a href=\"javascript:;\"&gt;&lt;/a&gt;&lt;a href=\"javascript:void 0;\"&gt;&lt;/a&gt;link.onclick=function()&#123; return false &#125;link.onclick=function(e)&#123;//=&gt;通过事件对象阻止默认行为 e=e||window.event; e.preventDefault?e.preventDefault():e.returnValue=false;&#125;","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-页面Load","slug":"JS基础-页面Load","date":"2018-01-26T16:48:54.000Z","updated":"2018-01-26T18:59:16.789Z","comments":true,"path":"2018/01/27/JS基础-页面Load/","link":"","permalink":"xiexiaoge.github.io/2018/01/27/JS基础-页面Load/","excerpt":"","text":"$(function(){})()或者$(document).ready(function(){}) VS window.onload $(function(){})()或者$(document).ready(function(){}) 可以在同一页面中使用多次,多次都生效(所以在使用JQ完成代码的时候,我们一般都会把代码写在回调函数中: 首先不仅等到DOM加载完成执行,而且还形成了一个闭包) JQ提供的方法,JQ基于DOMContentLoaded这个事件完成这个操作的 JQ中的事件绑定都是基于DOM2事件绑定完成的 s但是DOMContentLoaded在IE6~8下使用attchEvent也不支持的,JQ在IE6~8下使用attachEvent也是不支持的,JQ在IE6~8中使用的是readystatechange这个事件处理的 window.onload window.onload本身就是资源都加载完成才会执行,使用的是DOM零级事件绑定,在同一页面中只能绑定一次(绑定多个也是以最后一个为主); 如果想在一个页面中使用多次,应该基于DOM2事件绑定 function fn(){} 标准 window.addEventListener=(\"load\",fn,false) IE6~8 window.attachEvent=(\"onload\",fn)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"Interview questions","slug":"Interview-questions","permalink":"xiexiaoge.github.io/tags/Interview-questions/"}]},{"title":"JS基础-检测数据类型","slug":"JS基础-检测数据类型","date":"2018-01-25T18:06:08.000Z","updated":"2018-01-31T14:37:44.119Z","comments":true,"path":"2018/01/26/JS基础-检测数据类型/","link":"","permalink":"xiexiaoge.github.io/2018/01/26/JS基础-检测数据类型/","excerpt":"","text":"JS中的数据类型检测 typeof 用来检测数据类型的运算符 语法 : typeof [value] 返回结果 : 首先是一个字符串.字符串中包含了我们需要检测的数据类型 1234typeof 1&gt;1?0:2 //=&gt;2 先算 typeof 1 =&gt;\"number\" =&gt; \"number\"&gt;1?0:2 typeof null =&gt;\"object\" 虽然是基本数据类型,但是他属于空对象 , 检测的结果是对象(局限性)使用typeof有自己的局限性:不能具体细分当前的值是数组还是正则(也就是不能细分对象数据类型) instanceof &amp; constructor instanceof : 检测某一个实例是否隶属于某个类 constructor : 构造函数 使用instanceof 检测某个值是否属于某一个数据类型的内置类,从而检测出来他是否是这个类型的值;使用instanceof可以实现typeof实现不了的,对对象数据类型值详细的区分检测 使用instanceof 检测也有自己的弊端 基本数据类型值无法基于他检测 不管是哪一种方式创建基本数据类型的值,都是自己所属类的实例(只不过类型不一样而已)1234var num =12;var num2=new Number(12);num instanceof Number =&gt;falsenum2 instanceof 检测的原理是基于原型链检测的 : 只要当前类在实例的原型链上,最后返回的结果都是true 1234567891011121314151617181920var ary=[];ary.instanceof Array =&gt;trueary.instanceof Object =&gt;truefunction Fn()&#123;&#125;Fn.prototype=new Array();//=&gt;原型继承(Fn是Array的子类)var f=new Fn; f instanceof Array =&gt;true//=&gt;但是f其实不应该是数组,虽然在他的原型上可以找到数组,但是他不具备数组的基本结构,这也是instanceof的弊端``` `constructor`- 获取当前要检测数据值的constructor,判断它是否是某一个数据类型内置类来检测```javascriptvar ary=[];ary.constructor === Array =&gt;trueary.constructor=\"AA\";ary.constructor=\"Array\" =&gt;false//=&gt;constructor检测数据类型非常不可靠,因为这个属性是经常容易被修改的 {}.toString.call(val) 获取Object.prototype上的toString方法,让方法中的this变为需要检测的数据类型值,并且让方法执行 在Number String Boolean Array Function RegExp这些类的原型上都有一个toString方法,这个方法就是把本身的值转换为字符串 在Object这个类的原型上也有一个方法toString,但是这个方法并不是把值转换为字符串,而是返回当前值的所属类详细信息,固定结构: [object 所属类] 123456var obj=&#123;name:\"xxx\"&#125;;obj.toString();//=&gt;\"[object Object]\" 调取的正是Object.prototype.toString=&gt;首先执行Object.prototype.toString方法这个方法中的this就是我们操作的数值Object.prototype.toString执行的时候会返回当前方法中this的所属类信息也就是,向知道谁的所属类信息,我们就把这个toString方法执行,并且让this变为我们检测的这个数据值,那么方法返回的结果就是当前检测这个值的所属类的信息 使用toString检测数据类型,不管你是啥值,我们都可以正常检测出需要的结果","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-常用的ES6语法","slug":"JS基础-常用的ES6语法","date":"2018-01-25T17:46:55.000Z","updated":"2018-01-31T13:05:43.736Z","comments":true,"path":"2018/01/26/JS基础-常用的ES6语法/","link":"","permalink":"xiexiaoge.github.io/2018/01/26/JS基础-常用的ES6语法/","excerpt":"","text":"常用ES6语法 let基础语法 使用let 创建变量和使用var 创建变量的区别 let不存在变量提升机制 1234console.log(str);//=&gt;undefinedconsole.log(num);//=&gt;num is not definedvar str = \"string\";let num = 12; 使用let定义的变量不允许在同一个作用域中重复声明,单允许重新复制 var 相当与给window增加一个属性,和let不会给window增加属性; 关于暂时性死区 : 使用type检测一个未声明过去的变量 ES5中返回的结果是undefined但是不报错ES6中直接报错 ES6语法创建的变量(let)存在块级作用域,ES5语法创建变量(var/function)没有块级作用域 ES5window 全局作用域函数执行形成的私有作用域ES6除了有ES5中的两个作用域,ES6中新增加块级作用域(可以把块级作用域理解为之前学习的私有作用域:存在私有变量和作用域链的一些机制) ES6语法把大部分用大括号包起来的都称之为块级作用域循环体 if {} for(每一次循环都会形成一个新的块级作用域) try{}catch(){} switch(){case break} const基础语法 const和let 的区别 let是创建变量 , const是创建常量 变量: 值可以修改的 常量:值不能被修改 const 一旦声明必须赋值 JS中创建变量的方式 var : ES5中创建变量 function : ES5中创建函数 ES5中创建变量或者函数存在 : 变量提升,重复声明等特征,但是没有块级作用域的机制 相当于给 window增加一个私有属性 let : ES6中创建变量 const : ES6中创建常量 声明必须赋值,且不能修改 ES6中创建的变量或者常量都不可以变量提升,也不可以重复声明,而且还存在块级作用域 class: ES6中创建类的方式 12345678910class Parent&#123; //=&gt;私有 constructor()&#123; this.xxx=xxx &#125; //=&gt;Parent.prototype 原型 get()&#123;&#125; //=&gt;Parent own property 类本身的私有属性 static set()&#123;&#125;&#125; import: ES6中模块导入的方式 ES6中的解构赋值 按照原有值的解构 , 把原有值中的某一部分内容快速获取到(快速赋值给一个变量) 数组的解构赋值 结构赋值本身就是ES6的语法规范,使用什么声明这些变量是无所谓的 12345678910let [a,b,c] = [12,13,14];//=&gt;a=12 b=13 c=14var [d,e,f] = [16,17,18];//=&gt;d=16 e=17 f=18[a,b,c] = [12,13,14];//=&gt;相当于给window增加全局属性//=&gt;a=12 b=13 c=14//=&gt;这个操作在JS的严格模式下是不允许的,因为严格模式下不允许出现非使用var/let等声明的变量 多维数组的结构赋值 在解构赋值中,我们可以给某一项设置默认值 1let [,,,B=0] =[12,23,15];//=&gt;b=0 在解构赋值中,支持...xxx的扩展运算符 1let [...a]=[12,23,24];//=&gt;a=[12,23,24] 解构赋值的应用 快速交换两个变量的值123let a=12,b=13;[a,b]=[b,a];console.log(a, b); ES6模板字符串/h4&gt;- str=${变量}ES6类class 1234567891011121314class Fn&#123; constructor()&#123; super(); 私有属性 &#125; get()&#123; 公有属性 &#125; static set()&#123; 静态 类自己的 &#125;&#125;","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-类的继承","slug":"JS基础-类的继承","date":"2018-01-25T17:37:29.000Z","updated":"2018-01-31T10:38:12.829Z","comments":true,"path":"2018/01/26/JS基础-类的继承/","link":"","permalink":"xiexiaoge.github.io/2018/01/26/JS基础-类的继承/","excerpt":"","text":"类的继承 继承是:子类继承父类中的一些属性和方法 原型继承 原理:让子类的原型指向父类的实例 原型继承,并不是把父类的属性和方法COPY一份给子类,而是让子类的原型和父类原型之间搭建一个链接的桥梁,以后子类(或者子类的实例),可以通过原型链的查找机制,找到父类原型上的方法,从而调取这些方法使用即可 我们首先让子类的原型指向父类的实例,然后再向子类原型上扩展方法,防止提前增加方法,等原型重新指向后,之前在子类原型上扩展的方法都没用了(子类原型已经指向新的空间地址了)Childer.prototype=new Parent() 让子类原型重新指向父类实例,子类原型上原有的constructor就没有了,为了保证构造函数的完整性,最好给子类的原型重新手动设置constructor属性值Children.prototype.constructor=Children 特征(弊端) 子类不仅可以继承父类原型上的公有属性和方法,而且父类提供给实例的那些私有的属性方法,也被子类继承了(存放在子类原型上,作为子类公有的属性和方法) 12345function Parent()&#123;&#125;function Children( )&#123;&#125;Children.prototype=new Parent;Children.prototype.constructor=Children; call继承 原理 :在子类的构造函数中,把父类作为普通方法执行,让父类方法中的this指向子类的实例 把父类构造函数中私有的属性和方法,原封不动复制了一份给子类的实例(继承完成后,子类和父类是没关系的) 细节 我们一般把call继承放在子类构造体中的第一行,也就是创建子类实例的时候,进来第一件事就是先继承,然后在给实例赋值自己私有的(好处:自己的可以把继承过来的结果替换掉) 1234function Parent()&#123;&#125;function Children()&#123; Parent.call(this)&#125; 寄生组合继承 Object.create([obj]) : 创建一个空对象 , 把[obj] 作为新创建对象的原型 寄生组合式继承完成了一个需求: 子类公有的继承父类公有的(原型继承的变通) 子类私有的继承父类私有的(call继承完成的) 123456function Parent()&#123;&#125;function Children( Parent.call(this) )&#123;&#125;Children.prototype=Object.create(Parent.prototype);Children.prototype.constructor=Children; ES6继承 12345678910class A&#123; &#125;class B extends A&#123; constructor()&#123; super();//=&gt;相当于 call 继承 this.y=200 &#125;&#125;","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-定时器和同异步","slug":"JS基础-定时器和同异步","date":"2018-01-24T18:26:08.000Z","updated":"2018-01-24T18:47:52.270Z","comments":true,"path":"2018/01/25/JS基础-定时器和同异步/","link":"","permalink":"xiexiaoge.github.io/2018/01/25/JS基础-定时器和同异步/","excerpt":"","text":"JS中的定时器一共有两种 定时器的返回值:当我们设置定时器(不管是setTimeout还是setInterval),都会有一个返回值.返回值是一个数字,代表当前是在浏览器中设置的第几个定时器(返回的是定时器序号) setTimeout和setInterval虽然是处理不同需求的定时器,但是都是浏览器的定时器,所以设置的时候,返回的序号是依次排列的 setInterval设置完成定时器会有一个返回值,不管执行多少次,这个代表序列号的返回值不变(设置定时器就有返回值,执行多少次是定时器的处理) 123456var timer1=setTimeout(function () &#123; &#125;,1000); console.log(timer);//=&gt;1 var timer2=setTimeout(function () &#123; &#125;,1000); console.log(timer);//=&gt;2 定时器的清除clearTimeout(定时器的排队序号)clearInterval(定时器的排队序号)定时器需要手动清除 JS中的同步编程和异步编程JS是单线程的(一次只能执行一个任务,当前任务没有完成,下面的任务是不进行处理的) 同步编程(sync) : 任务是按照顺序一件件的完成的,当前任务没有完成,下面的任务不进行处理 异步编程(async) : 当前任务在等待执行的时候,我们不去执行,继续完成下面的任务,当下面的任务完成后,而是也到达等待的时候了,采取完成当前的任务 =&gt;定时器都是异步编程 =&gt;所有的事件绑定也是异步编程 =&gt;Ajax中有异步编程 =&gt;有些人把回调函数当作异步编程 其余都是同步编程 同步异步编程的核心原理:JS中有两个任务队列(存放任务列表的空间就是任务队列)1.主任务队列 : 同步执行任务(从上到下一次执*=&gt;游戏中的主线任务,只有做完了第一个才能做第二个 每个任务之间有联系2.等待任务队列 : 异步执行任务(日常任务/副线任务) 任务基本上是独立存在的 回调函数 把一个函数当作实参值传递给另一个函数,在另一个函数中执行这个函数,这种处理机制就是回调函数机制 数组中的 map ,forEach...","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-懒加载","slug":"JS基础-懒加载","date":"2018-01-24T18:02:19.000Z","updated":"2018-01-24T18:11:12.477Z","comments":true,"path":"2018/01/25/JS基础-懒加载/","link":"","permalink":"xiexiaoge.github.io/2018/01/25/JS基础-懒加载/","excerpt":"","text":"图片懒加载 当浏览器开始加载页面的时候,先不加载真实的图片(限用一张默认图占位),当页面加载完成或者滚动到对应区域的时候,我们再加载真实的图片 图片懒加载的目的: 减少页面第一次打开时候,请求资源的次数,让页面加载速度更快(打开页面的速度更快) 开始只加载第一屏幕区域的数据和图片(有的网站是第一屏和第二屏都加载了),剩下区域的内容和图片先不进行加载,当用户滚动到具体的区域的时候再加载,这样也可以为用户节省一些流量(尤其是移动端) window.onload VS JS中$() $(function(){})() 可以再统一页面中使用多次,多次都生效(所以在使用JQ完成代码的时候,我们一般都会把代码写在回调函数中: 首先不仅等到加载完成执行,而且还形成了一个闭包) 原理 : 利用了DOM二级事件绑定(可以执行多次),监听的是DOMContentLoaded事件(DOM结构加载完成就会触发) window.onload本身就是资源都加载完成才会执行,使用的是DOM零级事件绑定,在同一页面中只能使用一次","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-盒子模型","slug":"JS基础-盒子模型","date":"2018-01-23T17:57:09.000Z","updated":"2018-01-23T18:09:01.120Z","comments":true,"path":"2018/01/24/JS基础-盒子模型/","link":"","permalink":"xiexiaoge.github.io/2018/01/24/JS基础-盒子模型/","excerpt":"","text":"简单的CSS盒子模型JS盒子模型 JS提供一些属性和方法来描述当前盒子的样式的 clientWidth / clientHeight 当前盒子可视区域的宽度和高度 可视区域 : 内容宽高+padding clientWidth = width+padding(Left/Right) clientHeight = height+padding(Top/Bottom) 和内容是否溢出以及我们是否设置了overflow:hidden;没有关系12345//=&gt;获取当前页面一屏幕的宽度(加或者是为了兼容所有的浏览器)document.documentELement.clientWidth||document.body.clientWidth//=&gt;获取当前页面一屏幕的高document.documentELement.clientHeight||document.body.clientHeight clientTop和clientLeft 只有top和left,没有right和bottom这两个属性 clientTop : 盒子上边框的高度 clientLeft : 盒子左边框的宽度 获取的结果起始就是border-width值 offsetWidth 和 offsetHeight 在clientWidth和clientHeight基础上加上盒子的边框即可 和内容是否溢出没关系 在项目中如果想获取一个盒子的宽度和高度,一般用offsetWidth(而不是clientWIdth) , border也算是当前盒子的一部分 scrollWidth 和 scrollHeight 没有内容溢出获取的结果和clientWidth/clientHeight是一样的 有内容溢出真是内容的宽度或者高度(包含溢出的内容),再加上左padding或者上padding的值; 有内容溢出的情况下,通过scrollWIdth或者scrollHeight获取的结果是一个约等于的值 有内容溢出 , 每个浏览器对行高或者文字的渲染一样,导致获取的结果也不一样 是否设置overflow:hidden 对最后获取的结果也有影响12 //=&gt;获取当前页面真是高度(包含溢出部分)document.documentELement.scrollHeight||document.body.scrollHeight 在JS中获取元素具体的样式值 通过JS盒子模型属性来获取盒的结果都是盒子的组合样式值,不能直接获取某一个具体样式值,例如: 左padding…curELe.style.xxx 获取当前元素所有写在行内样式上的样式值 特殊 : 只有把样式写在行内样式上,才可以通过这种办法获取到(写在其它地方的样式是获取不到的) 这种方法用的很少 : 不可能把所有的样式都写在行内上(这样要内嵌和外链式就没有用了) window.getComputedStyle / currentStyle 只要当前元素在页面中显示出来了 , 就可以获取其样式值(不管写在行内还是样式表中) ; 也就是获取所有经过浏览器计算过的样式(当前元素只要能在页面中展示 , 那么它的所有样式都是经过浏览器计算的,包含一些你没有设置的 , 浏览器按照默认样式渲染的样式) window.getComputedStyle : 适用于标准浏览器,但是在IE6~8中就不兼容了 , IE6~8下哦我们使用curEle.currentStyle来过去需要的样式值 12345//=&gt;通过window.getComputedStyle获取的结果是一个对象,对象中包含了所有被浏览器计算过的样式属性及属性值//=&gt;window.getComputedStyle([当前需要操作的额元素],[当前元素的伪类,一般都写成null])//=&gt;在IE6~8浏览器的window全局对象中,没有提供getComputedStyle这个属性方法,我们只能使用currentStyle属性获取元素的样式//=&gt;[当前元素].currentStyle 获取的结果也是一个包含当前元素所有的样式属性和值的对象 把获取样式的操作封装成为一个公共的方法实现兼容:getCss 1234567891011121314151617/*getCss:获取当前元素的某一个样式属性值@parameter: curEle:当前需要操作的元素 attr: 当前需要获取的样式属性名@return 获取的样式属性值*/function getCss(curEle,attr)&#123; var value=null; if(\"getComputedStyle\" in window)&#123; value=window.getComputedStyle(curEle,null)[attr]; &#125;else&#123; value=curEle.currentStyle[attr] &#125; return value;&#125; 父级参照物 1234offsetParent:父级参照物(父级参照物不等价于父级元素;父级参照物和它的父级元素没有直接的关系)父级参照物:同一个平面中最外层的容器是所有里层盒子的父级参照物默认情况下,一个页面中所有元素的父级参照物都是BODY(而BODY的父级参照物是null)当我们给元素设置定位之后,会改变元素的父级参照物(因为设置定位会让元素脱离平面(脱离文档流)) offsetLeft offsetTop 当前元素的外边框 距离 父级参照物的内边框的偏移量(左偏移/上偏移) 标准IE8浏览器有特殊性:它的偏移量是从当前外边框~父级参照物的外边框 scrollLeft:横向滚动条卷去的宽度 scrollTop:竖向滚动条卷去的高度 注意 JS盒子模型属性都是”只读属性” : 只能通过属性获取值,不可以修改属性的值(修改也不生效),scrollLeft scrollTop但是这两个属性是”可读写属性”:不仅仅可以获取值,还可以修改 通过JS盒子模型属性获取到的结果是不带单位的,而且只能是整数(它会自动四舍五入)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-正则常用方法和应用","slug":"JS基础-正则常用方法和应用","date":"2018-01-23T17:37:00.000Z","updated":"2018-01-31T09:52:59.202Z","comments":true,"path":"2018/01/24/JS基础-正则常用方法和应用/","link":"","permalink":"xiexiaoge.github.io/2018/01/24/JS基础-正则常用方法和应用/","excerpt":"","text":"正则捕获 把当前字符串中符合正则字符串捕获到 RegExp.prototype : exec 实现正则捕获的方法 12345678910111213141516var str = \"回首2017展望2018\"var reg = /\\d+/;reg.exec(str);当正则捕获的时候:1.先去验证当前字符串和正则是否匹配,如果不匹配返回的结果是null(没有捕获到内容)2.如果匹配,从字符串最左边开始向右查找到匹配的内容,并且把匹配的内容返回exec捕获到结果的格式=&gt; 获取的结果是一个数组=&gt; 数组中的第一项是当前本次大正则再字符串中匹配到的结果=&gt; index:记录了当前本次捕获到结果的起始索引=&gt; input:当前正则操作的原始字符串=&gt; 如果当前正则中有分组,获取的数组中,从第二项开始都是每个小分组本次匹配到的结果(通过exec可以把分组中的内容捕获到)执行一次exec只能把符合正则规则条件中的一个内容捕获到,如果还有其它符合规则,需要再次执行exec才有可能捕获到 正则捕获的存在懒惰性 执行一次exec捕获到第一个符合规则的内容,第二次执行exec,捕获到的依然是第一个匹配的内容,后面匹配的内容不管执行多少次exec都无法捕获到 解决正则捕获的懒惰性: 在正则的末尾加修饰符g(全局匹配) 正则为什么会存在懒惰性 1234567正则本身有一个属性 : lastIndex(下一次正则在字符串中匹配查找的开始索引)默认是 : 0 从字符串中第一个字符开始查找匹配的内容默认不管执行多少遍exec方法,正则的lastIndex值都不会变(也就是第二次以后查找的时候还是从第一个字符查找,所以找到的结果永远都是第一个匹配的内容)而且当我们手动把lastIndex进行修改的时候,不会起到任何的作用//=&gt;为什么加修饰符 g 就解决了懒惰性//=&gt; 加了修饰符g,每一次exec结束后,浏览器默认会把lastIndex进行修改,下一次从上一次结束的位置开始查找,所以可以得到后面匹配的内容了 exec有自己的局限性 : 执行一次exec 只能捕获到一个和正则匹配的结果(即使加了修饰符g) , 如果需要都捕获到 , 我们需要执行 N 次exec方法才可以 1234567891011121314151617 RegExp.prototype.myExecAll=function myExecAll()&#123; //=&gt;this:当前需要处理的正则 var str = arguments[0]||\"\",result=[]; var ary = this.exec(str); if(!this.global)&#123; return ary //如果没有全局运算符g &#125; while(ary)&#123; result.push(ary[0]); ary=this.exec(str); &#125; return result&#125;var str = \"回首2017展望2018\"var reg = /\\d+/g;reg.myExecAll(); 使用字符串中的match实现捕获 123var str = \"回首2017展望2018\"var reg = /\\d+/g;str.match(reg)//=&gt;[\"2017\",\"2018\"]; 使用字符串match捕获: 如果正则加了修饰符g , 执行一次match会把所有正则匹配的内容捕获到 如果没有加修饰符g , 执行一次match只能把第一个匹配的结果捕获到 局限性: 在加了修饰符g的情况下 , 执行match方法只能把大正则匹配的内容捕获到 , 对于小分组捕获的内容方法给其自动忽略了12345678910111213var str = `my name is &#123;0&#125; , i am &#123;1&#125; years old~`;//=&gt;需求:把&#123;n&#125;整体捕获到,而且还要把括号中的数字也捕获到var reg = /\\&#123;(\\d+)\\&#125;/g;str.match(reg);//=&gt;[\"&#123;0&#125;\",\"&#123;1&#125;\"];//=&gt;想要得到获取小分组中的内容,使用EXEC处理function fn(reg,str)&#123; var ary=reg.exec(str),result=[]; while(ary)&#123; result.push(ary); ary.reg.exec(str); &#125; return result&#125; 使用test也可以实现正则的捕获 不管是正则匹配还是正则的捕获 , 在处理时候的原理是没有区别的 : “从字符串的第一个字符串向后查找 , 找到符合正则规则的字符 , 如果可以找到 , 说明正则和字符串匹配(test检测返回true , exec捕获返回捕获的内容) , 如果找到末尾都没有匹配的 , 说明正则和字符串不匹配(test返回false , exec捕获返回null)” 如果正则设置了修饰符g , 不管使用test还是exec中的任何方法 , 都会修改lastIndex值 (下一次查找是基于上一次匹配结果的末尾开始查找的) 1234567891011var str = `my name is &#123;0&#125; , i am &#123;1&#125; years old~`;var reg = /\\&#123;(\\d+)\\&#125;/g;var flag = reg.test(str);//=&gt;trueconsole.log(RegExp.$1);//=&gt;获取到当前本次匹配内容第一个小分组捕获的内容console.log(RegExp.$n)//=&gt;test可以实现捕获,但是每一次只能捕获到当前本次匹配结果中,第N个小分组捕获的内容 $1第一个分组 $2第二个分组....var trsult=[];while (reg.test(str))&#123; trsult.push(Regexp.$1);&#125; replace replace : 字符串中原有字符的替换 str.replace(old,new) 1234var str=\"小明18小明19\";str=str.replace(\"小明\",\"小明年龄\");//=&gt;在不使用正则情况下,执行一次replace只能替换一个原有字符,第二次执行replace,还是从字符串的开始位置查找,把最新找到的字符替换为新字符(类似于正则捕获时候的懒惰性,每一次执行都是从字符串最开始的位置查找) replace一般都是和正则搭配一起使用的 12var str=\"小明18小明19\";str=str.replace(/小明/g,\"小明年龄\"); replace 原理: 当replace方法执行,第一项传递一个正则正则不加g : 把当前字符串中第一个和正则匹配的结果替换成新的字符串正则加g : 把当前字符串中所有和正则匹配的内容都分别捕获到 , 而且每一次捕获 , 都会把当前获取的内容替换成新的字符串 当replace方法执行 , 第二次参数传递的是一个函数(回调函数)首先用正则到字符串中进行查找匹配,匹配到一个符合规则的,酒吧传递的函数执行一次不仅执行这个函数 , 而且还把正则本次捕获的结果(和执行exec捕获的结果一样: 数组 , 大正则匹配 , 小分组匹配都有) 当做实参传递给这个函数(这样就可以在函数中获取这些值) : 而这些值就是正则每一次捕获的结果123456789101112131415var str = `my name is &#123;0&#125; , i am &#123;1&#125; years old~`;var reg = /\\&#123;(\\d+)\\&#125;/g;str.replace(reg,function () &#123; //=&gt;传递的函数一共执行了2次 console.log(arguments);//每一次匹配捕获的结果,不仅把方法执行了,而且还会把当前捕获的结果当作实参传递给这个函数 //默认传的参数 //第一个参数arguments[0]: 表示大正则捕获的内容 //第二个参数arguments[1]: 第一个小分组捕获的参数 //第三个参数arguments[2]: 第二个小分组捕获的参数 //..... //倒数第二个参数: 大正则捕获内容首字符的索引 //最后一个参数: 原字符串 //return xxx //=&gt;每一次执行函数,函数中return的结果当相当于本次大正则匹配的内容替换掉(原字符串不变)&#125;); 正则捕获的方法 exec test match replace 都会存在懒惰性问题.想捕获全部加修饰符g都加g的情况下:exec需要执行多次不仅可以捕获大正则还可以把每个小分组的内容捕获到match执行一次全部捕获小分组的内容得不到test+RegExp在匹配的同时就捕获了只能获取小分组的内容不能捕获大正则的内容replace执行一次全部捕获不仅可以捕获大正则还可以把每个小分组的内容捕获到 所有支持正则的方法都可以实现正则的捕获(一般都是字符串方法) 字符串中常用的支持正则的方法 :matchsplitreplace…123456789101112var str = \"name=小明&amp;age=8&amp;lx=JS\";str.split(/&amp;|=/);//=&gt;[ 'name', '小明', 'age', '8', 'lx', 'JS' ];str.split(/(&amp;|=)/);//=&gt;[ 'name', '=', '小明', '&amp;', 'age', '=', '8', '&amp;', 'lx', '=', 'JS' ]//=&gt;在使用split进行字符串拆分的时候,如果正则中包含小分组,会把小分组中的内容都捕获到,放在最后的数组中str.split(/?:(&amp;|=)/);//=&gt;[ 'name', '小明', 'age', '8', 'lx', 'JS' ];//=&gt;只匹配不捕获//在当前一个分组中加了 ?: 在正则匹配的时候,小分组可以起到自己应有的作用(例如:改变优先级...) 但是在捕获的时候,遇到带?:的小分组,浏览器不会把它当成这个小分组中匹配的内容,单独去捕获了 单词首字母大写123456789101112131415var reg=/\\b\\w+\\b/g;var str= &quot;my name is xiao-ming , i am 8 years&quot;;//=&gt;\\b代表的边界:单词左右两边都是边界,-的左右两边也是边界,所以这里会把xiao-ming算成两个单词(我们想把它变成一个)// console.log(str.match(reg));//1.先把混淆边界的中杠替换为下划线str=str.replace(/-/g,&quot;_&quot;);// console.log(str.match(reg));//2.通过边界符匹配到每个单词str = str.replace(/\\b(\\w)(\\w*)\\b/g,function()&#123; return arguments[1].toUpperCase()+arguments[2];&#125;);//3.在把之前替换的下划线重新赋值为-str=str.replace(/_/g,&quot;-&quot;);console.log(str);replace应用 12var str=&quot;2018-01-23 14:55:00&quot;;//=&gt;2018年01月23日14时55分00秒 思路一 :字符串拆分法(不用) 先按照空格把字符串拆分成两部分 再把上面数组中的第一项和第二项分别获取到 按照连字符拆开 最后在把两个数组中的每一项按照指定格式拼接成新的字符串 思路二:使用日期数据完成操作首先把str变为标准的日期格式数据 new Data(str) //=&gt;Tue Jan 23 2018 14:55:00 GMT+0800 (中国标准时间)在IE浏览器下需要把原始字符串中的-替换成/才可以转换成 str.replace(/-/g,”/“)使用Date类中提供的方法获取到年,月,日,小时,分钟,秒,最后拼接成所需要的数据 思路三 : 12345678910111213var ary=[&quot;年&quot;,&quot;月&quot;,&quot;日&quot;,&quot;时&quot;,&quot;分&quot;,&quot;秒&quot;];var reg=/^(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)\\s+(\\d&#123;1,2&#125;):(\\d&#123;1,2&#125;):(\\d&#123;1,2&#125;)$/g;str=str.replace(reg,function () &#123; var result=&quot;&quot;; for(var i=0;i&lt;ary.length;i++)&#123; result+=(arguments[i+1]+ary[i]); &#125; return result // var arg=arguments; // return arg[1]+&quot;年&quot;+arg[2]+&quot;月&quot;+arg[3]+&quot;日&quot;+arg[4]+&quot;时&quot;+arg[5]+&quot;分&quot;+arg[6]+&quot;秒&quot; &#125;); console.log(str);简写 : str=str.replace(reg,&quot;$1年$2月$3日$4时$5分$6秒&quot;); 思路四 123var reg=/\\d+/g;var ary=str.match(reg);str=ary[0]+&quot;年&quot;+ary[1]+&quot;月&quot;...; 思路五 模板引擎 12345678910111213var reg=/\\d+/g;var ary=str.match(reg);var template=&quot;&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日&#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒&quot;;//=&gt;&#123;0&#125;-&gt;ary[0]//=&gt;&#123;1&#125;-&gt;ary[1]//=&gt;&#123;3&#125;-&gt;ary[2]//=&gt;...//=&gt;我们首先获取模板中的&#123;n&#125;(同时获取数字n),把数字n作为ary 的索引,获取到需要的日期数据,把获取的日期数据整体替换&#123;n&#125;即可template=template.replace(/\\&#123;(\\d+)\\&#125;/g,function () &#123; var index=arguments[1], value=ary[index]; return value;&#125;); 还有一个常用的url地址的解析!","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础­正则常用表达式","slug":"JS基础­正则常用表达式","date":"2018-01-23T17:31:14.000Z","updated":"2018-01-23T17:34:59.976Z","comments":true,"path":"2018/01/24/JS基础­正则常用表达式/","link":"","permalink":"xiexiaoge.github.io/2018/01/24/JS基础­正则常用表达式/","excerpt":"","text":"常用的正则表达式编辑(表单验证) 验证 18 - 65 之间的年龄 12345//=&gt;分三个阶段来处理// 18 | 19// 20 ~ 59// 60 ~ 65 var reg=/^((18|19)|([2-5]\\d)|(6[0-5]))$/ 验证是否为有效数字 1234//=&gt;可能是正数, 负数 , 整数 ,小数//=&gt;只要出现小数点,后面至少要跟一位数字//=&gt;小数点前面必须有数字var reg = /^-?(\\d|([1-9]\\d+))(\\.\\d+)?$/ 手机号 123//=&gt;11位数字//=&gt;1开头var reg = /^1\\d&#123;10&#125;$/; 用户名: 真是姓名 123//=&gt; /^[\\u4E00-\\u9FA5]$/ 中文汉字的正则var reg=/^[\\u4E00-\\u9FA5]&#123;2,10&#125;(\\.[\\u4E00-\\u9FA5]&#123;2,10&#125;)?/; 邮箱 1234567var reg = /^\\w+((-\\w+)|(\\.\\w+))*@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/;//=&gt; 以数字字母下划线开头//=&gt;@前面可以是 数字 字母 下划线 - . 这些符号//=&gt;不能把-和.连续出现 , 出现一次后面必须跟数字字母下划线//=&gt;@后面的部分支持 企业邮箱 .com .cn 多域名情况 身份证号码 1234567891011121314//=&gt; 18位 前17位数字最后以为数字|X//=&gt; 前六位:省市县//=&gt; 接下来八位出生年+月+日//=&gt; 倒数第二位 奇数:男 偶数:女var reg = /^(\\d&#123;6&#125;)(d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d)(\\d|X)$/;//=&gt;这样写不仅可以匹配,以后再捕获的时候,不仅可以把大正则匹配的结果捕获到,里面每一个小分组(小正则)匹配的结果也可以单独的捕获到\"分组捕获\"//=&gt;年 1950-2018 ((19[5-9]\\d)|(20((0\\d)|(1[0-8])))//=&gt;第一段 1950-1999 (19[5-9]\\d)//=&gt;第二段 2000-2018 (20((0\\d)|(1[0-8]))//=&gt;00-09 (0\\d)//=&gt;10-18 (1[0-8])//=&gt;月 (0[1-9]|1[0-2])//=&gt;日 (0[1-9]|[1-2]/d)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-正则基础","slug":"JS基础-正则基础","date":"2018-01-23T17:20:33.000Z","updated":"2018-01-23T17:30:28.416Z","comments":true,"path":"2018/01/24/JS基础-正则基础/","link":"","permalink":"xiexiaoge.github.io/2018/01/24/JS基础-正则基础/","excerpt":"","text":"什么是正则 正则就是一个规则 , 用来处理字符串的规则; 正则匹配编写一个规则 , 验证某个字符串是否符合这个规则 , 正则匹配使用的是test方法 正则捕获编写一个规则 , 在一个字符串中把符合规则的内容都获取到 , 正则捕获使用的方法 : 正则的exec方法 , 字符串中的split , replace , match 等方法都支持正则 1var reg = /^$/;//=&gt;两个斜杠中间包含一些内容就是正则,两个斜杠之间包含的内容都是元字符 正则的元字符和修饰符 任何一个正则都是由 元字符 和 修饰符 组成的 修饰符 g(global) : 全局匹配 i(ignoreCase) : 忽略单词大小写 m(mulitiline) : 多行匹配 元字符 量词元字符 + : 让前面的元字符出现一次或者多次 ? : 出现0到一次 * : 出现0到多次 {n} : 出现 n 次 {n,} : 出现n到多次 {n,m} : 出现n到m次 特殊意义的元字符 \\ : 转义字符(把一个普通字符转变为有特殊意义的字符,或者把一个有意义字符转换为普通的字符) . : 除了 \\n (换行符) 以外的任意字符 \\d : 匹配一个0~9之间的数字 \\D : 匹配一个非0~9之间的数字 \\w : 匹配一个 0~9 或字母或_之间的字符 \\W : 匹配一个非0~9 或字母或_之间的字符 \\s : 匹配一个任意空白字符 \\S : 匹配一个非任意空白字符 \\b : 匹配一个边界符 \\B : 匹配一个非边界符 x|y : 匹配x或者y中的一个 [a-z] : 匹配a-z中的任意一个字符 [^a-z] : 和上面的相反 , 匹配任意一个非a-z的字符 [xyz] : 匹配x或者y或者z中的一个字符 [^xyz] : 匹配除了xyz以外的任意字符 0 : 正则的小分组 , 匹配一个小分组(小分组可以理解为大正则中的一个小正则) ^ : 以某一个元字符开始 $ : 以某一个元字符结束 ?: : 只匹配不捕获 ?= : 正向预查 ?! :负向预查….除了以上特殊元字符和量词元字符,其余的都叫普通元字符 : 代表本身意义的元字符 元字符详细解读 ^ $1234567891011var reg=/\\d+/;var str=\"小哥2018\";reg.test(str)=&gt;truereg=/^\\d+/;reg.test(str)=&gt;falsereg=/^\\d+$/;=&gt;只能是某某某的,这里说明只能是1到多个数字reg.test(\"2018\");=&gt;truereg.test(str); =&gt;falsereg.test(\"2\");=&gt;true ^或者$只是一个修饰或者声明,不会占据字符串的位置 \\ 1234567891011121314151617181920 var reg = /^2.3$/; reg.test(\"2.3\");=&gt;true reg.test(\"2+3\");=&gt;true 点在正则中的意思:匹配除了\\n以外的任意字符,而不是单纯的小数点 var reg = /^2\\.3$/; reg.test(\"2.3\");=&gt;true reg.test(\"2+3\");=&gt;false 使用转义字符把点换位本身小数点的意思 好玩的来了: var reg = /^\\\\d$/;reg.test(\"\\9\")//=&gt;falsereg.test(\"\\\\d\")//=&gt;true var reg = /^\\\\\\d$/; reg.test(\"\\9\")//=&gt;false reg.test(\"\\\\9\")//=&gt;true var reg = /\\\\/; //=&gt; `\\\\`的意思 x|y 12345678var reg = /^18|19$/;// 18 或者 19 以1开头9结尾 中间 1或者8 以18开头或者以19结尾 =&gt;\"18小哥\" ,\"小哥19\" //=&gt;18 19 189 119 819 181 1819...很多都符合这个规则var reg = /^(18|19)$/;//=&gt;此时只有18或者19符合我们的规则了 () : 正则中的分组 , 也可以理解为一个大正则中的正则(包起来的部分是一个整体) ; 在正则中我们可以使用小括号 改变一些默认的优先级 小分组第二个作用 : 分组引用 小分组第三个作用 : 分组捕获 12//=&gt;分组引用 : \\1 或者 \\2 ...出现和第N个分组一摸一样的内容var reg = /^([a-z])([a-z])\\2([a-z])$/; [] 123456789//=&gt; 正则现实 正则中的\\wvar reg = /^([a-zA-Z0-9_)$/; //=&gt;中括号中出现的元字符,一般都代表本身的含义点在[]中就是小数点,不是所谓的任意字符;//=&gt;描述样式类名的规则(数字,字母,下划线,-),并且不能以-开头 var reg = /^[\\w-]+$/;var reg = /^([a-zA-Z0-9_-)+$/;","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-DOM映射回流重绘","slug":"JS基础-DOM映射回流重绘","date":"2018-01-22T18:53:53.000Z","updated":"2018-01-22T18:56:12.730Z","comments":true,"path":"2018/01/23/JS基础-DOM映射回流重绘/","link":"","permalink":"xiexiaoge.github.io/2018/01/23/JS基础-DOM映射回流重绘/","excerpt":"","text":"DOM映射机制 在JS中获取到的元素对象或者元素集合一般都和页面中的HTML结构存在映射关系(一个变另一个也会跟着变) 映射原理: 浏览器在渲染页面的时候给每个元素都设置了很多内置的属性(包含样式的) , 当我们在JS中把堆内存中的某一个内置属性的值修改了 , 大部分情况下 , 浏览器都会监听你的修改 , 然后按照最新修改的值重新渲染页面中的元素 当我们把页面中的HTML结果通过某些操作修改了(删除或者增加),我们无需要重新获取元素集合,元素集合的内容会自动跟着进行修改 通过quertSelectorAll获取到的元素集合(节点集合)不存在DOM的映射机制,因为获取到的集合不是标准的NodeList,而是属于StaticNodeList(静态的集合`) 操作真是的DOM在项目中是比较消耗性能的(尽量减少) 操作DOM或者修改DOM , 基本上就是触发它的重绘和回流机制 重绘 : 当一个元素的样式(特点 : 只有那些不修改元素位置的样式)发生改变的时候 , 浏览器会把当前元素进行重新的渲染(DOM性能消耗低) 回流 : 当一个元素的位置发生改变 , 浏览器会重新把整个页面的DIM结构进行计算 , 计算出所有元素的最新位置 , 然后再渲染(DOM性能消耗非常大) 新增或者删除一些元素 把现有元素的位置改变 文档碎片123//=&gt;解决了DOM回流非常消耗性能var fag=dowcument.createDocumentFragment();//=&gt;创建一个文档碎片(文档碎片 : 一个临时存储DOM元素的容器)//=&gt;把文档碎片的内容一次性添加到页面中(只触发一个DOM回流)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-JSON","slug":"JS基础-JSON","date":"2018-01-22T18:47:24.000Z","updated":"2018-01-31T10:40:43.573Z","comments":true,"path":"2018/01/23/JS基础-JSON/","link":"","permalink":"xiexiaoge.github.io/2018/01/23/JS基础-JSON/","excerpt":"","text":"JSON JSON在项目中经常被使用,客户端和服务器端的数据传输,目前大部分项目都是依托JSON格式来传输的 JSON只是一种数据格式,除了格式不一样.其他和正常的数据类型操作都一样 12var obj = &#123;name : &quot;小哥&quot;, age : 8&#125;;//=&gt;普通格式的对象var opp = &#123;&quot;name&quot; : &quot;小哥&quot; , &quot;age&quot; : 8&#125;;//=&gt;JSON格式的对象:把属性名用双引号(只能用双引号不能用单引号)包起来的格式叫做JSON格式的数据 window.JSON //=&gt;他是一个对象 , 里面提供了两个方法 parse , stringify JSON.parse : 把字符串(一般都是JSON格式的字符串)转换为JSON格式的对象,如果转换的字符串不是JSON格式的,转换的过程会报错这个方法在IE6-7中不兼容:不兼容,因为在IE6-7中,window对象中没有JSON这个对象 12var str=`[&#123;\"name\" : \"小哥\",\"age\":28&#125;,&#123;\"name\":\"小明\",\"age\":25&#125;]`;var jsonAry=JSON.parse(str); 在IE6-7中,我们可以使用eval来代替JSON.parse这个方法,实现把字符串转换为对象12var str=`[&#123;\"name\" : \"小哥\",\"age\":28&#125;,&#123;\"name\":\"小明\",\"age\":25&#125;]`;var jsonAry=eval(\"(\"+str+\")\");//=&gt;使用EVAL转换的时候,需要手动的给字符串外层加一个小括号,目的是为了防止有些数据不加括号报错 JSON.stringify : 把对象转化为JSON格式的字符串 12var ary=[name:\"小哥\",age:8];JSON.stringify(ary)//=&gt;`[&#123;\"name\":\"小哥\",\"age\":8&#125;]`","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-括号表达式和i++,++i","slug":"JS基础-括号表达式和i++,++i","date":"2018-01-22T18:37:09.000Z","updated":"2018-01-22T18:45:32.845Z","comments":true,"path":"2018/01/23/JS基础-括号表达式和i++,++i/","link":"","permalink":"xiexiaoge.github.io/2018/01/23/JS基础-括号表达式和i++,++i/","excerpt":"","text":"JS中的括号表达式 小括号中出现多项(每一个项目之间用逗号分隔),操作只有最后一项 1234567(function () &#123; console.log(1);&#125;,function () &#123; console.log(2);&#125;)();//=&gt;2 括号表达式会影响this 的指向 12345678910// =&gt;括号中只有一项,this还是按照没有括号的时候处理即可// =&gt;括号中有多项,执行最后一项的时候,方法中的this就是window(undefined)[浏览器会把这种情况理解为自执行函数处理的]window.name=&quot;WIN&quot;;function fn() &#123; console.log(this.name);&#125;var obj=&#123;name:&quot;obj&quot;,fn:fn&#125;;obj.fn();//this=&gt;obj(obj.fn)();//this=&gt;obj(fn,obj.fn)();//this=&gt;window 严格模式下是undefined 运算优先级 i++和++i的区别 i++: 先拿原有的i值和其他值进行运算,运算完成后在自身累加1++i: 先自身累加1,然后拿累加完成的结果和其他值进行运算1234567var i=5;console.log(5+i++);//10console.log(i)//=&gt;6var i=5;console.log(5+++i);//11console.log(i)//=&gt;6","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-函数的三种角色","slug":"JS基础-函数的三种角色","date":"2018-01-22T18:16:05.000Z","updated":"2018-01-22T18:23:40.900Z","comments":true,"path":"2018/01/23/JS基础-函数的三种角色/","link":"","permalink":"xiexiaoge.github.io/2018/01/23/JS基础-函数的三种角色/","excerpt":"","text":"函数的三种角色 普通函数 栈内存(私有作用域) 作用域链 arguments return … 第二种角色 : 类 类 实例 私有和公有属性 prototype __proto__ … 第三种角色 : 普通对象 键值对操作 … 三种角色没有直接的关系 1234567function Fn( var name = \"小哥\"; this.age=18;)&#123;&#125;Fn.prototypeFn();var f =new Fn();","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-call,apply,bind","slug":"JS基础-call-apply-bind","date":"2018-01-22T18:13:17.000Z","updated":"2018-01-22T18:36:01.485Z","comments":true,"path":"2018/01/23/JS基础-call-apply-bind/","link":"","permalink":"xiexiaoge.github.io/2018/01/23/JS基础-call-apply-bind/","excerpt":"","text":"call apply bind 都是天生自带的方法,所有的函数(类也是函数)都可以调取Function.prototype的方法:call/apply/bind 三个方法都是改变this指向的 call fn.call(context,para1,...) 把fn方法执行,并且让fn方法中的this 变为context,而para1…都是fn传递的实参 123456789101112131415161718//=&gt;非严格模式下function fn(num1,num2)&#123; console.log(this)&#125;var obj=&#123;fn:fn&#125;;fn();//=&gt;this:windowobj.fn();//=&gt;this:objvar opp=&#123;&#125;;//opp.fn();//=&gt;报错:opp中没有fn 这个属性fn.call(opp);//=&gt;this:opp num1&amp;&amp;num2 都是undefinedfn.call(1,2)//=&gt;this:1 num1=2 num2=undefinedfn.call(opp,1,2)//=&gt;this:opp num1=1 num2=2//=&gt;call方法的几个特殊性fn.call()//=&gt;this:windowfn.call(null)//=&gt;this:windowfn.call(undefined)//=&gt;this:window 12345//=&gt;JS严格模式下\"use strict\"fn.call();//=&gt;this:undefinedfn.call(undefined);//=&gt;this:undefinedfn.call(null);//=&gt;this:null call原理 1234567891011121314151617181920212223242526272829303132333435Function.prototype.call=function () &#123; //this:实例,f1 var ary=[...arguments]; if(ary[0]==undefined) &#123; //没传,null,undefined //让实例this()里面的this变成window //删除数组ary的第一项 ary.shift(); //把剩下的给this当参数穿进去,使用字符串拼接的形式 (eval(\"this(\"+ary+\")\")) //this(2,255) &#125;else &#123; //将传进来的参数变成一个对象 var obj=Object(arguments[0]); //给obj所属的原型上增加一个属性,属性值是this obj.__proto__.fn=this;//Object.prototype ary.shift(); eval(\"obj.fn(\"+ary+\")\"); //将增加的这个属性删除就可以了 delete obj.__proto__.fn; &#125; &#125;; function f1(m,n) &#123; console.log(this); console.log(m,n); &#125; var obj=&#123;&#125;; function f2() &#123; console.log(this); &#125; f1.call(f2,2,555); console.log(Object(2)); //Object()将传进来的内容变成一个对象返回 call深入 12345678910111213function fn1()&#123;&#125;function fn2()&#123;&#125;var obj=&#123;&#125;;fn1.call.call(obj);//=&gt;报错 fn1.call.call is not a function//=&gt;后面的call的作用: 1.f1.call执行 2.改变f1.call中的thisthis==&gt;obj obj不能执行所以说两个或两个以上call的时候,最后的call的第一个参数必须是一个函数fn1.call.call(fn2,obj)=&gt;fn2.call(obj)fn1.call.call....call(fn2,obj)=&gt;fn2.call(obj) apply apply的语法和call基本一致,作用原理也基本一致,唯一的区别: apply 把传递的函数的实参以数组的形式存放(但是也相当于在给函数一个个传递实参值) 12345678910fn.call(null,10,20,30);fn.apply(null,[10,20,30]);//=&gt;传递fn的时候也是一个个传递进去的//=&gt;求最大值 Array.prototype.myMax=function () &#123; return Math.max.apply(null,this) &#125;; ary.myMax(); //=&gt;还可以最小值,平均值,求和... bind 也是改变this的方法,它在IE6~8下不兼容;它和call(以及apply)改变this的原理不一样 12fn.call(opp,10,20);//=&gt;把fn执行,让fn中的this变为opp,并且把10&amp;&amp;20分别传递给fnfn.bind(opp,10,20);//=&gt;预先让fn中的this指向opp,并且把10和20预先传递给fn,此时的fn没有被执行(只有当执行的时候this和实参才会起到应有的作用) 项目中使用bind的意义123456789var obj = &#123;name:\"小哥\"&#125;;function fn(num1,num2)&#123; this.total=num1+num2;&#125;//=&gt;需求:一秒后执行fn(定时器驱动),执行fn的时候,让fn中的this-&gt;obj,并且给fn传递两个实参10,201. window.setTimeout(fn.bind(obj,10,20),1000);2. window.setTimeout(function()&#123; fn.call(obj,10,20)&#125;,1000)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-原型和原型链","slug":"JS基础-原型和原型链","date":"2018-01-21T15:14:24.000Z","updated":"2018-01-23T08:50:37.708Z","comments":true,"path":"2018/01/21/JS基础-原型和原型链/","link":"","permalink":"xiexiaoge.github.io/2018/01/21/JS基础-原型和原型链/","excerpt":"","text":"原型和原型链 原型 所有的函数都天生自带一个属性: prototype(原型),它是一个对象数据类型的值 , 在当前prototype对象中,存储了类需要给实例使用的公有的属性和方法 prototype这个对象,浏览器会默认为其开辟一个堆内存,在这个堆内存中天生自带一个属性constructor(构造函数),这个属性存储的值就是当前函数本身 每一个类的实例(每一个对象)都天生自带一个属性: __proto__ , 属性值是当前对象所属类的原型(prototype)1234567 function Fn(name,age)&#123; this.name=name; this.age=age; this.say=function()&#123; console.log(\"my name is\"+this.name+\"! i am \" + this.age +\"years old !\"); &#125;&#125; 原型链 当对象通过对象.属性或者(对象[“”])获取属性的值,首先看是不是自己的私有属性,是的话就获取私有的属性,不是的话通过proto找到所属类的原型,看看原型上有没有这个共有属性,还是没有在通过原型上的proto去找…一直找到object的原型上,还没有就是undefined这个查找过程就叫做原型链 关于原型链中提供的私有(公有)中的this指向问题 看点前面是谁,this就是谁 把需要执行方法中的this进行替换 替换完成后,如果想要知道结果,只需要按照原型链的查找机制去查找即可 基于自定义类的原型扩展方法 1234function Fn(name,age)&#123; this.name=name; this.age=age;&#125;; 设置别名(小名) 1234var pro=Fn.prototype;//=&gt;指向同一个堆内存 pro.get=function () &#123;&#125;; pro.set=function () &#123;&#125;;constructor问题和之前原型上的方法 内置类不允许重新构造原型 重新构造原型 123456Fn.prototype=&#123; //=&gt; 让原型指向自己开辟的堆内存有一个问题:自己开辟的堆内存中没有constructor这个属性,所以实例在调取constructor的时候找到的是Object,这样不好,此时我们应该重新设置一下constructor,保证机制的完整性 constructor:Fn, get:function () &#123;&#125;, set:function () &#123;&#125;&#125;; 12345678910111213在JQ中就是采用了重新构造原型的方式~function () &#123; var jQuery=function (seletor,context) &#123; return new jQuery.fn.init(seletor,context) &#125;; jQuery.fn=jQuery.prototype=&#123; constructor:jQuery, init:function (seletor,context) &#123; &#125; &#125;; window.$=window.jQuery=jQuery;&#125;(); 基于内置类的原型扩展方法 我们新增加的方法最好设置一个前缀,防止我们新增加的方法内置的方法冲突,把内置方法替换掉 实现链式写法,这样执行完成这个方法后,我们还可以继续调取其它的方法 123456789101112131415161718Array.prototype.myDistinct=function () &#123; var obj=&#123;&#125;; for(var i=0;i&lt;this.length;i++)&#123; var item=this[i]; if(typeof obj[item] !==&quot;undefined&quot;)&#123; this[i]=this[this.length-1]; this.length--; i--; continue; &#125; obj[item]=item; &#125; obj=null; return this;//实现链式写法,返回去重后的数组,这样执行完成这个方法后,我们还可以继续调取数组中的方法&#125;;let ary=[1,6,4,5,2,5,5];ary.myDistinct();console.log(ary);","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-构造函数模式","slug":"JS基础-构造函数模式","date":"2018-01-21T15:03:22.000Z","updated":"2018-01-21T15:13:25.282Z","comments":true,"path":"2018/01/21/JS基础-构造函数模式/","link":"","permalink":"xiexiaoge.github.io/2018/01/21/JS基础-构造函数模式/","excerpt":"","text":"构造函数设计模式(constructor) 使用构造函数方式,主要是为了创建类和实例的,也就是基于面向对象编程思想来实现一些需求的处理 在JS中, 当我们使用new xxx()执行函数的时候,此时的函数就不是普通的函数了,而是变为了一个类,返回的结果叫做当前类的实例,把这种new xxx执行的方式称之为构造函数设计模式1234function Fn()&#123; ...&#125;var f = new Fn();//=&gt; Fn是一个类,f是当前这个类的一个实例 \"构造函数设计模式\"(我们一般都会把类名第一个字母大写) 普通函数执行 VS 构造函数执行 普通函数执行 开辟一个新的私有作用域 形参赋值 变量提升 代码自上而下执行(return 后面的值就是当前函数返回的结果) 栈内存释放或者不释放1234567function fn(num)&#123; this.num=num;//this-&gt;window 相当于给全局对象增加一个num的属性,属性值是 形参num var total=null; total+=num; return total&#125;var f=fn(10); //=&gt; 10 构造函数执行 首先和普通函数执行一样,也需要开辟一个新的私有作用域 私有作用域中完成类似于普通函数的操作: 形参赋值以及变量提升 在代码自上而下执行之前,构造函数有属于自己比较特殊的操作 : 浏览器会在当前的作用域中默认创建一个对象数据类型的值,并且会让当前函数中的this指向创建的这个对象 像普通函数一样,代码自上而下执行:this.xxx=xxx这里操作都是在给创建的这个对象增加属性名和属性值 代码执行完之后,即时然后中没有写return,在构造函数模式中: 浏览器会默认把创建的对象返回到函数的外面12345 function Fn(num)&#123; //=&gt;在构造函数模式中,方法中出现的this是当前类的一个实例(this.xxx=xxx都是给当前实例添加一些私有的属性) this.num=num;&#125;var f=new Fn(10); 构造函数执行,即具备普通函数执行的一面,也同时具备自己独有的一些操作 在构造函数执行期间,浏览器默认创建的对象(也就是函数体中的this)就是当前这个类的一个实例,浏览器会把默认创建的实例返回,所以 new Fn(), Fn是一个类,返回的结果是Fn这个类的一个实例 深入理解构造函数执行的步骤 当构造函数或者类,执行的时候不需要传递任何的实参值,此时我们是否加小括号就不重要了(不需要传递实参的情况下,小括号可以省略) 构造函数执行,同时具备了普通函数执行的一面,也有自己特殊的一面,但是和实例相关的只有自己特殊的一面才相关(也就是this.xxx=xxx才相当于给当前实例增加的私有属性),函数体中出现的私有变量,和实例都没有直接的关系 通过类创建出来的每一个实例都是单独的个体(单独的堆内存空间) , 实例和实例之间是不相同并且独立互不影响的(市面上部分开发把这种模式叫做单例模式,这种说法是错的,JS中这种模式叫做构造函数设计模式) 在构造函数体中,通过this.xxx=xxx给实例设置的属性都是当前实例的私有属性 12345678910111213function Fn()&#123; var num=100; this.name=\"小哥\";&#125;var f1=new Fn();var f2=new Fn//=&gt;私有变量和实例没关系console.log(f1.num)// nudefinedconsole.log(f1.name)// \"小哥\"//=&gt;不同实例是不同的空间地址 console.log(f1===f2) //false 当构造函数体中我们手动的设置了return(默认返回的是实例:对象数据类型值),return的是一个基本类型值,对最后返回的实例没有任何影响,但是如果返回的是引用数据类型的值的话,会把默认返回的实例替换掉123456789101112function Fn()&#123; this.name=\"小哥\"; return 10;&#125;var f=new Fn();//=&gt;f依然是当前类的一个实例function Fn()&#123; this.name=\"小哥\"; return &#123;name:\"小明\"&#125;;&#125;var f=new Fn();//=&gt;f不再是Fn是实例,而是变为手动返回的对象了 instanceof 用来检测当前实例是否隶属某个类 123function Fn()&#123;&#125;var f=new Fn;console.log(f instanceof Fn) //=&gt;true instanceof解决了typeof无法识别是数组还是正则的问题 12[] instanceof Array // =&gt; true/^$/ instanceof Array //=&gt; false hasOwnProperty VS in in : 用来检测当前这个是属性是否隶属于对象(不管是对象私有的还是公有的属性,只要有返回的就是true) hasOwnProperty : 用来检测当前这个属性是否是对象的私有属性(不仅是对象的属性,而且需要是私有的才可以) 1234567var obj = &#123;name:\"小哥\",age:18&#125;;\"name\" in obj //=&gt;true\"sex\" in obj //=&gt;false\"hasOwnProperty\" in obj //=&gt;truehas是Oobject这个内之类中提供的属性方法,只要当前对象是Objeact的一个实例,就可以使用这个方法obj.hasOwnProerty(\"name\") //=&gt;true 检测一个属性是否是当前对象的公有属性 是对象的一个属性 不是对象的私有属性1234567function hasPubProPerty (obj,property) &#123; obj = obj.toString() == \"[object Object]\" ? obj : &#123;&#125;; property=typeof property==\"string\"?property:\"\"; return (property in obj) &amp;&amp;(obj.hasOwnProperty(property)===false); // return property in obj?obj.hasOwnProperty(property)?false:true:false&#125;console.log(hasPubProPerty (&#123;name: \"小哥\"&#125;, \"hasOwnProperty\"));","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-面向对象","slug":"JS基础-面向对象","date":"2018-01-20T16:40:59.000Z","updated":"2018-01-20T16:52:49.916Z","comments":true,"path":"2018/01/21/JS基础-面向对象/","link":"","permalink":"xiexiaoge.github.io/2018/01/21/JS基础-面向对象/","excerpt":"","text":"面向对象(oop) 面向对象是编程思想 HTML和CSS是标记语言不是编程语言,没有所谓的面向对象编程 LESS和SASS属于CSS预编译语言,把CSS编程编程语言(面向对对象) 对象,类,实例 对象 : 编程语言中的对象是一个泛指,万物皆对象(所要研究学习以及使用的都是对象) 类 : 对象的具体细分(按照对象或者特性细分为一些类别) 实例 : 某一类中具体的事物 实际生活中 自然界中万物皆对象,我们为了认知自然界,我们会把自然界中的事物按照特征进行分类,例如: 动物类 人类 正常人类 程序猿类 爬行动物类 植物类 微生物类 …每个程序员就是程序猿类别中的一个实例 JS本身就是基于面向对象创造出来的语言(所以它是面向对象编程),我们想要学习JS,首先也是给其进行分类,拿出某一勒种的实例,进行学习和研究 JS中常用的内置类 关于数据类型的 Number : 每一个数字或者NaN是它的一个实例 String : 字符串类 Boolean : 布尔类 Undefined / Null : 浏览器屏蔽了我们操作Null或者Undefined这个类 Object : 对象类,每一个对象数据类型都是它的实例 Array : 数组类 RegExp : 正则类 Date : 日期类 … Function : 函数类,每一个函数都是它的一个实例 关于元素对象和元素集合的 HTMLCollection : 元素集合类 NodeList : 节点集合类 HTMLElement HTML类 Element 标签类 Node 节点类 EventTarget 事件类 12345678 //=&gt;元素集合类 getElementsByTagName getElementsByClassName querySelectorAll//=&gt;节点集合类 getELementsByName childNodes 学习面对对象对于小白的意义 研究数组: 创建一个数组类的实例,研究其基础语法和结构 如果想要研究数据具备的功能方法,我们只需要看Array/Object这些类上都赋予了它什么样的方法 document.getElementById它的上下文只能是document,其它不不可以? 因为getElementById这个方法只有Document这个类才有,其它类没有,所以只有document这个作为Document的实例才能使用这个方法 基于面向对象创建数据值 引用数据类型 1234567891011121314//=&gt;字面量创建方式 var ary =[1,2,3];// 基于面向对象(构造函数)方式创建一个数组 var ary = new Array(); 两种创建方式在核心意义上没有差别,都是创建Array这个类的一个实例,但是语法上是有去别的 1. 字面量创建方式传递进来什么,都是给数组每一项加入的内容 2. 构造函数创建方式 new Array(10); 创建一个长度为10的数组,每一项都是空 new Array(\"10\");如果只传递一个实参,并且实参不是数组,相当于把当前值作为一个数组的第一项存起来 new Array(10,20,30):如果传递多个实参,不设置长度,而是把传递的内容当作数组中的每一项存储起来var obj=&#123;name:\"小哥\"&#125;;var obj=new Object();//=&gt;一般只用于创建空对象,如果需要增加键值对,创建完成后自己依次添加即可 基本数据类型 12345var num =12 ;//=&gt;字面量创建出来的是一个基本数据类型值(但是也是Number的一个实例,可以调取Number赋予它的方法)typeOf num //=&gt; &quot;number&quot;var num = new Number(12);//=&gt;构造函数方式创建出来的也是Number的一个实例(也可以使用Number赋予它的方法),但是获取的结果是对象数据类型的typeOf num //=&gt; &quot;object&quot;","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-单例模式","slug":"JS基础-单例模式","date":"2018-01-20T16:23:52.000Z","updated":"2018-01-20T16:36:16.027Z","comments":true,"path":"2018/01/21/JS基础-单例模式/","link":"","permalink":"xiexiaoge.github.io/2018/01/21/JS基础-单例模式/","excerpt":"","text":"单例模式 把对象数据类型实现把描述同一件事物或者特征归纳汇总在一起,以此来避免全局变量问题的方式和思想叫做:单例设计模式 123456789101112131415161718//=&gt;单例模式//1.singleto不仅仅是对象名了,在单例模式中.singleton称之为\"命名空间(nameSpace)\"var singleton=&#123; xxx:xxx, ...&#125;;var singletonFn=&#123; nameSace1:&#123; xxx:xxx, .... &#125;nameSace2:&#123; xxx:xxx, .... &#125;.....&#125; 在项目中,为了实现模块化开发或者团队协作开发,我们经常应用单利模式(一般页面逻辑部分的代码都是依托单例模式设计规划的);模块化开发,在团队协作开发的时候,我们经常会把一个复杂页面,按照具体的功能划分成为几大块,然后分别去开发,这种模式划分的思想就是模块化开发思想 使用单例模式实现模块化开发 在自己命名空间下调用其他命名空间的方法,指定好对应的命名空间名即可1234567891011example 1var singleton1=&#123; show:function()&#123; &#125;&#125;var stinleton2=&#123; hide:function()&#123; singleton1.show(); &#125;&#125; 调用本模块中的一些方法,可以直接使用this处理即可,此方法中的this一般都是当前模块的命名空间123456789example 2var singleton1=&#123; show:function()&#123; &#125;, hide:function()&#123; this.show(); &#125;&#125; 高级单例模式 基础JS高级编程技巧惰性思想来实现的单例模式,并且可以把一些常用的设计模式(例如:命令模式,发布订阅设计模式,promise设计模式等)融合进来,最后清晰的规划我们的业务逻辑代码,方便后期二次开发和维护,这种设计思想综合体就是高级单例模式,也是项目中最常应用的 单例模式+发布订阅模式 12345678910111213141516171819var searchModel=(function()&#123; var $searchPlan=$.Callbacks();//jQuery中的发布订阅模式 function submit()&#123; .... &#125; $searchPlan.add(sumbit); function fn()&#123; .... &#125; $searchPlan.add(fn); return&#123; init:function()&#123; $searchPlan.fire() &#125; &#125;&#125;)()searchModel.init();","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-作用域和闭包","slug":"JS基础-作用域和闭包","date":"2018-01-20T07:18:37.000Z","updated":"2018-01-22T18:43:24.546Z","comments":true,"path":"2018/01/20/JS基础-作用域和闭包/","link":"","permalink":"xiexiaoge.github.io/2018/01/20/JS基础-作用域和闭包/","excerpt":"","text":"JS中的堆内存和栈内存 栈内存俗称叫做作用域(全局作用域/私有作用域) 为JS代码提供执行的环境(执行JS代码的地方) 基本数据类型值是直接存放在栈内存中的 堆内存存储数据类型值(相当于一个存储的仓库) 对象存储的是键值对 函数存储的是代码字符串 在项目中,内存越少性能越好,需要把一些没用的内存处理掉 栈内存和堆内存的销毁 堆内存 函数执行形成一个私有作用域,如果私有作用域中的部分内容被以外的变量占用了,当前作用域不销毁 函数执行返回一个引用数据类型堆内存地址(并且堆内存隶属于这个作用域),在外面有一个变量接受了这个返回值,此时当前作用就不能销毁(想要销毁,只需要让外面的变量赋值给null,也就是不占用当前作用域中的内容了) 栈内存 全局作用域在加载页面的时候执行,在关掉页面的时候销毁 私有作用域一般情况下,函数执行形成栈内存,函数执行完,浏览器会把执行的栈内存自动释放;特殊情况:私有作用域的部分内存被其他作用域知道了,那么该栈内存就属于被占用,不会被销毁,常见的两种情况:1. 函数执行返回一个引用类型的值,且在别的作用域被接收了,该栈内存不会被销毁 2. 私有作用域中,给DOM元素的事件绑定方法,该栈内存不会被销毁 作用域 全局作用域: window 私有作用域: 函数执行 块级作用域:使用let创建变量存在块级作用域 作用域链 当前作用域代码执行的时候遇到一个变量,首先看它是否属于私有变量,如果是当前作用域私有变量,那么以后私有作用域中遇到这个变量都是操作私有的(闭包); 如果当前这个变量不是私有的,我们需要向它的上级作用域进行查找,上级如果也没有,则继续向上查找,一直找到window全局作用域为止,我们把着种查找机制叫做作用域链;全局下右,操作的就是全局变量,全局下没有(设置:给全局对象window增加了属性&amp;&amp;获取:报错) 查找私有变量 JS中的私有变量有且有两种 在私有作用域变量提升阶段,声明过的变量(或函数) 形参也是私有变量1234567example 1function fn(num1,num2)&#123; // total,num1,num2 私有变量 var total=num1+num2; return total&#125;var result=fn(100,200) 函数执行 函数执行形成一个新的私有作用域 形参赋值 变量提升 代码自上而下执行 当前栈内存(私有作用域)销毁或者不销毁 123456789101112131415example 2//全局作用域下的变量提升 var x,y,z,fn=xxxfff1111var x=10,y=20,z=30;function fn(x,y)&#123; //私有作用域 // 形参赋值: x=10,y=20 (x,y)私有变量 // 变量提升 var x(忽略的,因为已经存在x这个名字了) console.log(x,y,z);//z全局变量 10 20 30 var x=100;//私有的x=100 y=200;//私有的y=200 z=300;//全局的z变成300 console.log(x,y,z);//100,200,300&#125;fn(x,y,z);//fn 执行传递的是实参(实参都是值)console.log(x, y, z); //10 20 300 123456789101112131415example 3//全局变量 fn=&gt;xxxfff111function fn(b)&#123; //私有作用域 // 形参赋值 b=1 //变量提升 b=&gt;函数 console.log(b);// 函数b function b() &#123; //私有作用域 //形参赋值和变量提升都没有 console.log(b);//函数b &#125; b();&#125;fn(1); 如何查找上一级作用域? 函数执行形成一个私有作用域(A),A的上级作用域是谁,和他在哪执行的没关系,主要看他是在哪定义的,在哪个作用域下定义的,当前A的上级作用域就是谁; 12345678910examplt 4var n=10;function sum() &#123; console.log(n);&#125;//sum(); =&gt;10~function () &#123; var n=100; sum();//=&gt;10 sum的宿主环境是当前自执行函数形成的私有作用域&#125;(); 闭包 函数执行,形成一个私有作用域,保护里面的私有变量不受到外界的干扰,这种保护机制叫做 闭包 闭包的作用(保护) 形成私有作用域,保护里面的私有变量不受外界的干扰 JQuery:常用的JS类库,提供很多项目中常用的方法(兼容所有浏览器) Zepto: 小型JQ,专门为移动端开发准备的 123456789101112131415161718//=&gt;JQ代码片段(function(window)&#123; var jQuery=function()&#123; ...&#125;;window.jQuery=window.$=jQuery;&#125;)(window)jQuery()$()//=&gt;Zepto代码片段var Zepto=(function()&#123; var Zepto=function()&#123; ... &#125; return Zepto&#125;)()Zepto(); 在项目中,利用这种保护机制,实现团队协作开发(避免了多人同一个命名,导致代码冲突的问题) 闭包的作用(保存) 函数执行形成一个私有作用域,函数执行完成,形成的这个栈内存一般情况下都会自动释放 特殊情况:函数执行完成,当前私有作用域(栈内存)中的某一部分被栈内存以外的其它东西(变量/元素的事件)占用了,当前的栈内存就不能释放掉,也就形成了不销毁的私有作用域(里面的私有变量也不会销毁)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-this问题","slug":"JS基础-this问题","date":"2018-01-20T07:14:38.000Z","updated":"2018-01-22T18:12:20.099Z","comments":true,"path":"2018/01/20/JS基础-this问题/","link":"","permalink":"xiexiaoge.github.io/2018/01/20/JS基础-this问题/","excerpt":"","text":"在JS非严格模式下(默认模式就是非严格模式) 自执行函数中的this一般都是window 1234567var obj=&#123; fn:(function)&#123; //this-&gt;window return function()&#123; &#125; &#125;()&#125; 给元素的某一个事件绑定方法 , 当事件触发 , 方法执行的时候 , 绑定的这个方法中的this一般是当前操作的这个DOM元素 12345678910111213oBox.onclick=function()&#123; //=&gt;当绑定的方法执行,方法中的this=&gt;oBox //=&gt;如何让绑定的方法执行: // 1. 手动点击oBox,经浏览器触发点击事件 // 2. oBox.onclick(); //...&#125; //=&gt;在IE6~8下,如果我们使用的是DOM2事件绑定,方法执行的时候,里面的this不是当前元素而是 window oBox.addEventListener(\"click\",function()&#123; //this=&gt;window&#125;) 还有一个方式可以快速区别this : 当方法执行的时候,看看方法名前面是否有点,有点,点前面是谁this就是谁,没有点一般都是window 123456789var obj=&#123; name: \"obj\", fn:function()&#123; console.log(this) &#125;&#125;obj.fn();//this-&gt;objvar f=obj.fn;f();//this-&gt;window 当一个函数作为参数的时候，this也是window 在构造函数执行的时候,函数体中的this一般都是当前类的实例 12345function Fn()&#123; //=&gt;this:当前Fn的实例(当前案例中指的是f),而this.xxx=xxx都是给当前实例设置的私有属性 this.xxx=xxx;&#125;var f = new Fn(); 使用Function.prototype上提供的call,apply,bind实现this改变 1234567891011var obj = &#123;name:\"小哥\"&#125;;function fn(num1,num2)&#123; this.total=num1+num2;&#125;//=&gt;call基础语法的应用fn(10,20);//=&gt;this:windowfn.call(obj,10,20);//=&gt;首先让fn中的this指向传递的第一个参数值obj,然后执行fn这个函数;此时fn中的this-&gt;obj num1-&gt;10 num2-&gt;20fn.call();//=&gt;this:undefinedfn.call(null);//=&gt;this:undefinedfn.call(undefined);//=&gt;this:undefined 在ES6中 , 新增加的箭头函数 , 箭头函数中没有执行主体 , 箭头的函数中this会继承它宿主环境中的this 1234567891011121314151617181920212223var Obj = &#123; fn:function()&#123; //=&gt;this : obj setTimeout(function()&#123; //=&gt;this : window &#125;,1000); //=&gt;想让定时器函数中的this也是obj 1.setTimeout(function()&#123; //=&gt;this : obj &#125;.bind(this),1000) &#125;; 2. var _this=this; setTimeout(function()&#123; //=&gt;_this : obj &#125;,1000) &#125;; 3. setTimeout(()=&gt;&#123; //=&gt;this : obj 箭头函数中this继承宿主环境中的this &#125;,1000) &#125;&#125;obj.fn(); 切记: this是谁和他在哪定义的以及在哪执行的没有任何关系 在JS严格模式下(让JS更加严谨) 开始严格模式 : 在当前作用域的第一行加上&quot;user strict&quot;,开启严格模式,那么当前作用域下在执行的JS代码都是按照严格模式处理的;12\"user strict\";//=&gt;当前JS代码都开启了严格模式(包含了函数中的代码) 1234~function()&#123;\"use strict\";//-&gt;只是把当前私有作用域开启了严格模式(对外面全局没有影响)&#125;(); 在JS严格模式下,如果执行主题不明确,this指向的是undefined(非严格模式下指向的是window)","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-变量提升","slug":"JS基础-变量提升","date":"2018-01-19T17:24:53.000Z","updated":"2018-01-20T17:10:43.145Z","comments":true,"path":"2018/01/20/JS基础-变量提升/","link":"","permalink":"xiexiaoge.github.io/2018/01/20/JS基础-变量提升/","excerpt":"","text":"变量提升 在当前作用域中js代码自上而下执行之前,浏览器首先会把所有带var/function关键字的进行提前声明或者定义 声明(declare): var num; 在当前作用域中定义一个名字 定义(defined): num=12;把声明的名字赋一个值 带 var 关键字的只是提前的声明一下; 带function关键字的在变量提升阶段把声明和定义都完成了 123456789example 1 var num =13;function fn()&#123; console.log(a)//undefined var a=10; console.log(a)//10&#125;fn();console.log(num);//13 定义变量的时候带 var 和不带var 的区别?&gt; [带var]- 在当前作用域中声明了一个变量,如果当前是全局作用域,也相当于给全局作用域设置了一个属性叫做a12345example 1 console.log(a) 报错 a is not defined a=12; console.log(a) //12 console.log(window.a)// 12&gt; [不带var]- 在全局作用域中,如果不带var,仅仅是给全局对象设置了一个新的属性名(把window.省略了)12345example 2 console.log(a) //undefined var a =12; console.log(a) //12 console.log(window.a)// 12以后项目中,如果是为了创建变量,最好不要省略var,这样会更加严谨一些作用域链 函数执行形成一个私有的作用域(可以保护私有变量),进入到私有作用域中,首先变量提升(声明过的变量是私有的),接下来代码执行 1.执行的时候遇到一个变量,如果这个变量是私有的,那么按照私有处理即可 123456789function fn()&#123; //=&gt;[私有作用域] //变量提升 var a;(私有变量) console.log(a);//undefined var a=12; console.log(a);//12&#125;;fn();console.log(a);// a is not defined 2.如果当前这个变量不是私有的,我们需要向它的上级作用域进行查找,上级如果也没有,则继续向上查找,一直找到window全局作用域为止,我们把这种查找机制叫做作用域链 1) 如果上级作用域有,操作的都是上级作用域中的变量(假如我们在当前作用域把值改了,相当于把上级作用域中的这个值给修改了) 2) 如果上级作用域没有这个变量(找到window也没有): 变量=值:相当于给window添加一个属性 以后在操作window下就有了 console.log(变量): 想要输出这个变量,如果这个变量没有的,所以会报错 1234567function fn()&#123; //console.log(a);//a is not defined a=12; console.log(a);//12&#125;;fn();console.log(a);//12 综合例子 12345678910111213example 1//=&gt;变量提升 var x; var y; fn=AAAFFF111;console.log(x, y);//undefined undefinedvar x=10,y=20;function fn() &#123; //=&gt;[私有作用域] //=&gt;变量提升:var x;(x是私有变量) console.log(x, y);//x undefined ,y 20 var x=y=100; // window.y=100 console.log(x, y);//x 100 y 100&#125;fn();console.log(x,y); //10 100 注意: 这里的 var x=y=100;=&gt;var x=100 ; y=100; 只有x是一个变量,y只是window下面的一个属性, 因为从右到左赋值 只对等号左边的进行变量提升 只对等号左边进行变量提升,右边是值,不会提前声明什么的; 我们创建函数的时候,可以使用函数表达式的方式: 因为只能对等号左边的进行变量提升,所以变量提升完成后,当前只是声明了,没有定义,想要执行函数,只能放在赋值的代码之后(放在前面执行相当于undefined执行,会报错) 这样让代码逻辑更加严谨,以后想要知道一个执行的函数做了什么功能,只需要向上查找定义的部分即可(不会存在定义的代码在执行下面的情况) 实名函数 1234567var fn=function sum () &#123; console.log(sum);//-&gt;函数本身 console.log(1); console.log(arguments.callee);//-&gt;函数本身&#125;;//sum()=&gt;报错 sum is not definedfn(); 不管条件是否成立都要进行变量提升 不管条件是否成立,判断体中出现的var/function都会进行变量提升,但是在最新版本浏览器中,function声明的变量只能提前声明不能定义了(前提:函数是在判断题体中)123456console.log(num, fn);//undefined,undefinedif(1!==1)&#123; var num=12; function fn()&#123; &#125;&#125; 代码执行的条件判断 [条件不成立]进入不到判断体中,赋值的代码执行不了,此时之前声明的变量或者函数依然是undefined [条件成立]进入条件判断体中的第一件事情不是代码执行,而是把之前变量提升没有定义的函数首先定义了(进入到判断体中函数就定义了;迎合ES6中的块级作用域)123456789console.log(num, fn);//undefined,undefinedif(1==1)&#123; console.log(num);//undefined console.log(fn);//函数体本身 var num=12; function fn()&#123; &#125;&#125; console.log(fn);//函数体本身 老版本浏览器不是这样处理的: 不管条件是否成立,都要进行变量提升(和新版本不一样的地方,新版本function只是声明,老版本function依然是声明+定义) 关于重名的处理 在变量提升阶段,如果名字重复了,不会重新的进行声明,但是会重新的进行定义(后面赋的值会把前面赋的值替换掉) 特殊变量提升的情况 = 右边不进行变量提升 自执行函数不进行变量提升 匿名函数当作参数的时候不进行变量提升 函数执行return后面的代码不执行但是需要变量提升,return出的代码执行但是不进行变量提升 if判断中的变量提升,不管条件是否成立都进行变量提升,新版本中var跟function都是只声明不定义,代码执行的时候,条件一旦成立,先给函数赋值,然后代码执行 let 和const 定义变量时,没有变量提升","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-数据类型的核心操作原理","slug":"JS基础-数据类型的核心操作原理","date":"2018-01-19T03:38:09.000Z","updated":"2018-01-20T08:08:49.400Z","comments":true,"path":"2018/01/19/JS基础-数据类型的核心操作原理/","link":"","permalink":"xiexiaoge.github.io/2018/01/19/JS基础-数据类型的核心操作原理/","excerpt":"","text":"js中的数据类型 基本数据类型(值类型) number string boolean null undefined 引用数据类型 对象 {} 普通对象 [] 数组 /^$/ 正则 函数 类 JS代码运行在浏览器中,是因为浏览器给我们提供了一个供js代码执行的环境-&gt;全局作用域(window/global) 1234567891011121314151617181920212223example 1 let a= 12;// 只是给变量a 赋值 让a 和12建立链接关系 let b= a; //b-&gt;a=12 b=13; //b=13 console.log(a); ***12***个人解析:只是把a的值赋值给b ,a和b还是独立的互不影响example 2 let o=&#123;name:\"小哥\"&#125;;//-&gt;o开辟了一个内存空间(aaafff111) let p=o;// -&gt; p=o-&gt;(aaafff111) p.name=\"小明\";// -&gt; aaafff111空间的name=\"小明\" console.log(o.name);// o.name-&gt;aaafff111.name-&gt;小明***小明***个人解析:因为引用数据类型,所以o,p指向地址aaafff111,p.name是堆内存中的name(后面的o,p都看成aaafff111去理解)example 3 let m=&#123;name:\"小哥\"&#125;;//-&gt;o开辟了一个堆内存(aaafff111) let n=m;//n=m-&gt;aaafff111 n=&#123;name:\"小明\"&#125;;// 这里的n 重新指向了新的地址,也就是n开辟了一个堆内存, 以后的 m和n就是独立的 console.log(m.name)个人解析:因为n重新指向了新的地址,所以以后的n和m都是独立的***小哥*** 值类型 直接按值操作,例如 let a=12;直接把12这个值赋值给变量a(让a变量和12这个值建立了链接关系) 对象数据类型 在JS中遇到对象,会严格按照如下的步骤操作: 浏览器为起开辟一个新的内存空间,为了方便后期可以找到这个空间,浏览器给空间分配一个16进行的地址(堆内存) 按照一定顺序,分别把对象键值对存储到内存空间中 把开辟内存的地址赋值给变量(或者其它的东西),以后变量就可以通过地址找到内存空间,然后进行一些操作 函数的操作 创建函数 开辟一个新的内存空间(为其分配一个16进制的地址) 把函数体中编写的js代码当作 字符串 存放到空间中(函数值创建不执行没有意义) 把分配的地址赋值给声明的函数名 执行函数 目的:执行函数体中的代码 函数执行的时候,浏览器会形成一个新的私有作用域(只能执行函数体中的代码)供函数体中的代码执行 执行代码之前,先把创建函数存储的那些字符串变为真正的js表达式,按照从上到下的顺序在私有作用域下执行 一个函数可以被执行N次,每一次执行相互之间互不干扰","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]}]}